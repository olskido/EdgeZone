
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model MarketSnapshot
 * 
 */
export type MarketSnapshot = $Result.DefaultSelection<Prisma.$MarketSnapshotPayload>
/**
 * Model WalletEvent
 * 
 */
export type WalletEvent = $Result.DefaultSelection<Prisma.$WalletEventPayload>
/**
 * Model Signal
 * 
 */
export type Signal = $Result.DefaultSelection<Prisma.$SignalPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model SmartWallet
 * 
 */
export type SmartWallet = $Result.DefaultSelection<Prisma.$SmartWalletPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tokens
 * const tokens = await prisma.token.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tokens
   * const tokens = await prisma.token.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketSnapshot`: Exposes CRUD operations for the **MarketSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketSnapshots
    * const marketSnapshots = await prisma.marketSnapshot.findMany()
    * ```
    */
  get marketSnapshot(): Prisma.MarketSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletEvent`: Exposes CRUD operations for the **WalletEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletEvents
    * const walletEvents = await prisma.walletEvent.findMany()
    * ```
    */
  get walletEvent(): Prisma.WalletEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signal`: Exposes CRUD operations for the **Signal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signals
    * const signals = await prisma.signal.findMany()
    * ```
    */
  get signal(): Prisma.SignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.smartWallet`: Exposes CRUD operations for the **SmartWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmartWallets
    * const smartWallets = await prisma.smartWallet.findMany()
    * ```
    */
  get smartWallet(): Prisma.SmartWalletDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Token: 'Token',
    MarketSnapshot: 'MarketSnapshot',
    WalletEvent: 'WalletEvent',
    Signal: 'Signal',
    WalletTransaction: 'WalletTransaction',
    SmartWallet: 'SmartWallet'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "token" | "marketSnapshot" | "walletEvent" | "signal" | "walletTransaction" | "smartWallet"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      MarketSnapshot: {
        payload: Prisma.$MarketSnapshotPayload<ExtArgs>
        fields: Prisma.MarketSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>
          }
          findFirst: {
            args: Prisma.MarketSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>
          }
          findMany: {
            args: Prisma.MarketSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>[]
          }
          create: {
            args: Prisma.MarketSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>
          }
          createMany: {
            args: Prisma.MarketSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>[]
          }
          delete: {
            args: Prisma.MarketSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>
          }
          update: {
            args: Prisma.MarketSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.MarketSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.MarketSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketSnapshotPayload>
          }
          aggregate: {
            args: Prisma.MarketSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketSnapshot>
          }
          groupBy: {
            args: Prisma.MarketSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<MarketSnapshotCountAggregateOutputType> | number
          }
        }
      }
      WalletEvent: {
        payload: Prisma.$WalletEventPayload<ExtArgs>
        fields: Prisma.WalletEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>
          }
          findFirst: {
            args: Prisma.WalletEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>
          }
          findMany: {
            args: Prisma.WalletEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>[]
          }
          create: {
            args: Prisma.WalletEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>
          }
          createMany: {
            args: Prisma.WalletEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>[]
          }
          delete: {
            args: Prisma.WalletEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>
          }
          update: {
            args: Prisma.WalletEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>
          }
          deleteMany: {
            args: Prisma.WalletEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>[]
          }
          upsert: {
            args: Prisma.WalletEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletEventPayload>
          }
          aggregate: {
            args: Prisma.WalletEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletEvent>
          }
          groupBy: {
            args: Prisma.WalletEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletEventCountArgs<ExtArgs>
            result: $Utils.Optional<WalletEventCountAggregateOutputType> | number
          }
        }
      }
      Signal: {
        payload: Prisma.$SignalPayload<ExtArgs>
        fields: Prisma.SignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findFirst: {
            args: Prisma.SignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findMany: {
            args: Prisma.SignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          create: {
            args: Prisma.SignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          createMany: {
            args: Prisma.SignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          delete: {
            args: Prisma.SignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          update: {
            args: Prisma.SignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          deleteMany: {
            args: Prisma.SignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SignalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          upsert: {
            args: Prisma.SignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          aggregate: {
            args: Prisma.SignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignal>
          }
          groupBy: {
            args: Prisma.SignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalCountArgs<ExtArgs>
            result: $Utils.Optional<SignalCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      SmartWallet: {
        payload: Prisma.$SmartWalletPayload<ExtArgs>
        fields: Prisma.SmartWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SmartWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SmartWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>
          }
          findFirst: {
            args: Prisma.SmartWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SmartWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>
          }
          findMany: {
            args: Prisma.SmartWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>[]
          }
          create: {
            args: Prisma.SmartWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>
          }
          createMany: {
            args: Prisma.SmartWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SmartWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>[]
          }
          delete: {
            args: Prisma.SmartWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>
          }
          update: {
            args: Prisma.SmartWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>
          }
          deleteMany: {
            args: Prisma.SmartWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SmartWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SmartWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>[]
          }
          upsert: {
            args: Prisma.SmartWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmartWalletPayload>
          }
          aggregate: {
            args: Prisma.SmartWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSmartWallet>
          }
          groupBy: {
            args: Prisma.SmartWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<SmartWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.SmartWalletCountArgs<ExtArgs>
            result: $Utils.Optional<SmartWalletCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    token?: TokenOmit
    marketSnapshot?: MarketSnapshotOmit
    walletEvent?: WalletEventOmit
    signal?: SignalOmit
    walletTransaction?: WalletTransactionOmit
    smartWallet?: SmartWalletOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TokenCountOutputType
   */

  export type TokenCountOutputType = {
    snapshots: number
    walletEvents: number
    transactions: number
  }

  export type TokenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshots?: boolean | TokenCountOutputTypeCountSnapshotsArgs
    walletEvents?: boolean | TokenCountOutputTypeCountWalletEventsArgs
    transactions?: boolean | TokenCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenCountOutputType
     */
    select?: TokenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketSnapshotWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountWalletEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletEventWhereInput
  }

  /**
   * TokenCountOutputType without action
   */
  export type TokenCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    price: Decimal | null
    liquidity: Decimal | null
    volume24h: Decimal | null
    marketCap: Decimal | null
    momentumScore: number | null
    convictionScore: number | null
  }

  export type TokenSumAggregateOutputType = {
    price: Decimal | null
    liquidity: Decimal | null
    volume24h: Decimal | null
    marketCap: Decimal | null
    momentumScore: number | null
    convictionScore: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    name: string | null
    ticker: string | null
    contract: string | null
    chain: string | null
    pairAddress: string | null
    dexId: string | null
    logoUrl: string | null
    price: Decimal | null
    liquidity: Decimal | null
    volume24h: Decimal | null
    marketCap: Decimal | null
    createdAt: Date | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
    pairCreatedAt: Date | null
    lastIngestedAt: Date | null
    momentumScore: number | null
    convictionScore: number | null
    threatLevel: string | null
    smartWalletFlow: boolean | null
    clusterDetected: boolean | null
    aiSummary: string | null
    aiSummaryUpdated: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ticker: string | null
    contract: string | null
    chain: string | null
    pairAddress: string | null
    dexId: string | null
    logoUrl: string | null
    price: Decimal | null
    liquidity: Decimal | null
    volume24h: Decimal | null
    marketCap: Decimal | null
    createdAt: Date | null
    firstSeenAt: Date | null
    lastSeenAt: Date | null
    pairCreatedAt: Date | null
    lastIngestedAt: Date | null
    momentumScore: number | null
    convictionScore: number | null
    threatLevel: string | null
    smartWalletFlow: boolean | null
    clusterDetected: boolean | null
    aiSummary: string | null
    aiSummaryUpdated: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    name: number
    ticker: number
    contract: number
    chain: number
    pairAddress: number
    dexId: number
    logoUrl: number
    price: number
    liquidity: number
    volume24h: number
    marketCap: number
    createdAt: number
    firstSeenAt: number
    lastSeenAt: number
    pairCreatedAt: number
    lastIngestedAt: number
    momentumScore: number
    convictionScore: number
    threatLevel: number
    smartWalletFlow: number
    clusterDetected: number
    aiSummary: number
    aiSummaryUpdated: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    price?: true
    liquidity?: true
    volume24h?: true
    marketCap?: true
    momentumScore?: true
    convictionScore?: true
  }

  export type TokenSumAggregateInputType = {
    price?: true
    liquidity?: true
    volume24h?: true
    marketCap?: true
    momentumScore?: true
    convictionScore?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    name?: true
    ticker?: true
    contract?: true
    chain?: true
    pairAddress?: true
    dexId?: true
    logoUrl?: true
    price?: true
    liquidity?: true
    volume24h?: true
    marketCap?: true
    createdAt?: true
    firstSeenAt?: true
    lastSeenAt?: true
    pairCreatedAt?: true
    lastIngestedAt?: true
    momentumScore?: true
    convictionScore?: true
    threatLevel?: true
    smartWalletFlow?: true
    clusterDetected?: true
    aiSummary?: true
    aiSummaryUpdated?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    name?: true
    ticker?: true
    contract?: true
    chain?: true
    pairAddress?: true
    dexId?: true
    logoUrl?: true
    price?: true
    liquidity?: true
    volume24h?: true
    marketCap?: true
    createdAt?: true
    firstSeenAt?: true
    lastSeenAt?: true
    pairCreatedAt?: true
    lastIngestedAt?: true
    momentumScore?: true
    convictionScore?: true
    threatLevel?: true
    smartWalletFlow?: true
    clusterDetected?: true
    aiSummary?: true
    aiSummaryUpdated?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    name?: true
    ticker?: true
    contract?: true
    chain?: true
    pairAddress?: true
    dexId?: true
    logoUrl?: true
    price?: true
    liquidity?: true
    volume24h?: true
    marketCap?: true
    createdAt?: true
    firstSeenAt?: true
    lastSeenAt?: true
    pairCreatedAt?: true
    lastIngestedAt?: true
    momentumScore?: true
    convictionScore?: true
    threatLevel?: true
    smartWalletFlow?: true
    clusterDetected?: true
    aiSummary?: true
    aiSummaryUpdated?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    name: string
    ticker: string
    contract: string
    chain: string
    pairAddress: string | null
    dexId: string | null
    logoUrl: string | null
    price: Decimal
    liquidity: Decimal
    volume24h: Decimal
    marketCap: Decimal
    createdAt: Date
    firstSeenAt: Date
    lastSeenAt: Date
    pairCreatedAt: Date | null
    lastIngestedAt: Date | null
    momentumScore: number
    convictionScore: number
    threatLevel: string
    smartWalletFlow: boolean
    clusterDetected: boolean
    aiSummary: string | null
    aiSummaryUpdated: Date | null
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ticker?: boolean
    contract?: boolean
    chain?: boolean
    pairAddress?: boolean
    dexId?: boolean
    logoUrl?: boolean
    price?: boolean
    liquidity?: boolean
    volume24h?: boolean
    marketCap?: boolean
    createdAt?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    pairCreatedAt?: boolean
    lastIngestedAt?: boolean
    momentumScore?: boolean
    convictionScore?: boolean
    threatLevel?: boolean
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: boolean
    aiSummaryUpdated?: boolean
    snapshots?: boolean | Token$snapshotsArgs<ExtArgs>
    walletEvents?: boolean | Token$walletEventsArgs<ExtArgs>
    transactions?: boolean | Token$transactionsArgs<ExtArgs>
    signal?: boolean | Token$signalArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ticker?: boolean
    contract?: boolean
    chain?: boolean
    pairAddress?: boolean
    dexId?: boolean
    logoUrl?: boolean
    price?: boolean
    liquidity?: boolean
    volume24h?: boolean
    marketCap?: boolean
    createdAt?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    pairCreatedAt?: boolean
    lastIngestedAt?: boolean
    momentumScore?: boolean
    convictionScore?: boolean
    threatLevel?: boolean
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: boolean
    aiSummaryUpdated?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ticker?: boolean
    contract?: boolean
    chain?: boolean
    pairAddress?: boolean
    dexId?: boolean
    logoUrl?: boolean
    price?: boolean
    liquidity?: boolean
    volume24h?: boolean
    marketCap?: boolean
    createdAt?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    pairCreatedAt?: boolean
    lastIngestedAt?: boolean
    momentumScore?: boolean
    convictionScore?: boolean
    threatLevel?: boolean
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: boolean
    aiSummaryUpdated?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    name?: boolean
    ticker?: boolean
    contract?: boolean
    chain?: boolean
    pairAddress?: boolean
    dexId?: boolean
    logoUrl?: boolean
    price?: boolean
    liquidity?: boolean
    volume24h?: boolean
    marketCap?: boolean
    createdAt?: boolean
    firstSeenAt?: boolean
    lastSeenAt?: boolean
    pairCreatedAt?: boolean
    lastIngestedAt?: boolean
    momentumScore?: boolean
    convictionScore?: boolean
    threatLevel?: boolean
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: boolean
    aiSummaryUpdated?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ticker" | "contract" | "chain" | "pairAddress" | "dexId" | "logoUrl" | "price" | "liquidity" | "volume24h" | "marketCap" | "createdAt" | "firstSeenAt" | "lastSeenAt" | "pairCreatedAt" | "lastIngestedAt" | "momentumScore" | "convictionScore" | "threatLevel" | "smartWalletFlow" | "clusterDetected" | "aiSummary" | "aiSummaryUpdated", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshots?: boolean | Token$snapshotsArgs<ExtArgs>
    walletEvents?: boolean | Token$walletEventsArgs<ExtArgs>
    transactions?: boolean | Token$transactionsArgs<ExtArgs>
    signal?: boolean | Token$signalArgs<ExtArgs>
    _count?: boolean | TokenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      snapshots: Prisma.$MarketSnapshotPayload<ExtArgs>[]
      walletEvents: Prisma.$WalletEventPayload<ExtArgs>[]
      transactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
      signal: Prisma.$SignalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ticker: string
      contract: string
      chain: string
      pairAddress: string | null
      dexId: string | null
      logoUrl: string | null
      price: Prisma.Decimal
      liquidity: Prisma.Decimal
      volume24h: Prisma.Decimal
      marketCap: Prisma.Decimal
      createdAt: Date
      firstSeenAt: Date
      lastSeenAt: Date
      pairCreatedAt: Date | null
      lastIngestedAt: Date | null
      momentumScore: number
      convictionScore: number
      threatLevel: string
      smartWalletFlow: boolean
      clusterDetected: boolean
      aiSummary: string | null
      aiSummaryUpdated: Date | null
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snapshots<T extends Token$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Token$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    walletEvents<T extends Token$walletEventsArgs<ExtArgs> = {}>(args?: Subset<T, Token$walletEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Token$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Token$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    signal<T extends Token$signalArgs<ExtArgs> = {}>(args?: Subset<T, Token$signalArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly name: FieldRef<"Token", 'String'>
    readonly ticker: FieldRef<"Token", 'String'>
    readonly contract: FieldRef<"Token", 'String'>
    readonly chain: FieldRef<"Token", 'String'>
    readonly pairAddress: FieldRef<"Token", 'String'>
    readonly dexId: FieldRef<"Token", 'String'>
    readonly logoUrl: FieldRef<"Token", 'String'>
    readonly price: FieldRef<"Token", 'Decimal'>
    readonly liquidity: FieldRef<"Token", 'Decimal'>
    readonly volume24h: FieldRef<"Token", 'Decimal'>
    readonly marketCap: FieldRef<"Token", 'Decimal'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly firstSeenAt: FieldRef<"Token", 'DateTime'>
    readonly lastSeenAt: FieldRef<"Token", 'DateTime'>
    readonly pairCreatedAt: FieldRef<"Token", 'DateTime'>
    readonly lastIngestedAt: FieldRef<"Token", 'DateTime'>
    readonly momentumScore: FieldRef<"Token", 'Int'>
    readonly convictionScore: FieldRef<"Token", 'Int'>
    readonly threatLevel: FieldRef<"Token", 'String'>
    readonly smartWalletFlow: FieldRef<"Token", 'Boolean'>
    readonly clusterDetected: FieldRef<"Token", 'Boolean'>
    readonly aiSummary: FieldRef<"Token", 'String'>
    readonly aiSummaryUpdated: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token.snapshots
   */
  export type Token$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    where?: MarketSnapshotWhereInput
    orderBy?: MarketSnapshotOrderByWithRelationInput | MarketSnapshotOrderByWithRelationInput[]
    cursor?: MarketSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketSnapshotScalarFieldEnum | MarketSnapshotScalarFieldEnum[]
  }

  /**
   * Token.walletEvents
   */
  export type Token$walletEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    where?: WalletEventWhereInput
    orderBy?: WalletEventOrderByWithRelationInput | WalletEventOrderByWithRelationInput[]
    cursor?: WalletEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletEventScalarFieldEnum | WalletEventScalarFieldEnum[]
  }

  /**
   * Token.transactions
   */
  export type Token$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Token.signal
   */
  export type Token$signalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    where?: SignalWhereInput
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model MarketSnapshot
   */

  export type AggregateMarketSnapshot = {
    _count: MarketSnapshotCountAggregateOutputType | null
    _avg: MarketSnapshotAvgAggregateOutputType | null
    _sum: MarketSnapshotSumAggregateOutputType | null
    _min: MarketSnapshotMinAggregateOutputType | null
    _max: MarketSnapshotMaxAggregateOutputType | null
  }

  export type MarketSnapshotAvgAggregateOutputType = {
    price: Decimal | null
    liquidity: Decimal | null
    volume: Decimal | null
    marketCap: Decimal | null
    fdv: Decimal | null
    priceChange24h: Decimal | null
  }

  export type MarketSnapshotSumAggregateOutputType = {
    price: Decimal | null
    liquidity: Decimal | null
    volume: Decimal | null
    marketCap: Decimal | null
    fdv: Decimal | null
    priceChange24h: Decimal | null
  }

  export type MarketSnapshotMinAggregateOutputType = {
    id: string | null
    tokenId: string | null
    price: Decimal | null
    liquidity: Decimal | null
    volume: Decimal | null
    marketCap: Decimal | null
    fdv: Decimal | null
    priceChange24h: Decimal | null
    timestamp: Date | null
  }

  export type MarketSnapshotMaxAggregateOutputType = {
    id: string | null
    tokenId: string | null
    price: Decimal | null
    liquidity: Decimal | null
    volume: Decimal | null
    marketCap: Decimal | null
    fdv: Decimal | null
    priceChange24h: Decimal | null
    timestamp: Date | null
  }

  export type MarketSnapshotCountAggregateOutputType = {
    id: number
    tokenId: number
    price: number
    liquidity: number
    volume: number
    marketCap: number
    fdv: number
    priceChange24h: number
    timestamp: number
    _all: number
  }


  export type MarketSnapshotAvgAggregateInputType = {
    price?: true
    liquidity?: true
    volume?: true
    marketCap?: true
    fdv?: true
    priceChange24h?: true
  }

  export type MarketSnapshotSumAggregateInputType = {
    price?: true
    liquidity?: true
    volume?: true
    marketCap?: true
    fdv?: true
    priceChange24h?: true
  }

  export type MarketSnapshotMinAggregateInputType = {
    id?: true
    tokenId?: true
    price?: true
    liquidity?: true
    volume?: true
    marketCap?: true
    fdv?: true
    priceChange24h?: true
    timestamp?: true
  }

  export type MarketSnapshotMaxAggregateInputType = {
    id?: true
    tokenId?: true
    price?: true
    liquidity?: true
    volume?: true
    marketCap?: true
    fdv?: true
    priceChange24h?: true
    timestamp?: true
  }

  export type MarketSnapshotCountAggregateInputType = {
    id?: true
    tokenId?: true
    price?: true
    liquidity?: true
    volume?: true
    marketCap?: true
    fdv?: true
    priceChange24h?: true
    timestamp?: true
    _all?: true
  }

  export type MarketSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketSnapshot to aggregate.
     */
    where?: MarketSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSnapshots to fetch.
     */
    orderBy?: MarketSnapshotOrderByWithRelationInput | MarketSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketSnapshots
    **/
    _count?: true | MarketSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketSnapshotMaxAggregateInputType
  }

  export type GetMarketSnapshotAggregateType<T extends MarketSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketSnapshot[P]>
      : GetScalarType<T[P], AggregateMarketSnapshot[P]>
  }




  export type MarketSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketSnapshotWhereInput
    orderBy?: MarketSnapshotOrderByWithAggregationInput | MarketSnapshotOrderByWithAggregationInput[]
    by: MarketSnapshotScalarFieldEnum[] | MarketSnapshotScalarFieldEnum
    having?: MarketSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketSnapshotCountAggregateInputType | true
    _avg?: MarketSnapshotAvgAggregateInputType
    _sum?: MarketSnapshotSumAggregateInputType
    _min?: MarketSnapshotMinAggregateInputType
    _max?: MarketSnapshotMaxAggregateInputType
  }

  export type MarketSnapshotGroupByOutputType = {
    id: string
    tokenId: string
    price: Decimal
    liquidity: Decimal
    volume: Decimal
    marketCap: Decimal
    fdv: Decimal | null
    priceChange24h: Decimal | null
    timestamp: Date
    _count: MarketSnapshotCountAggregateOutputType | null
    _avg: MarketSnapshotAvgAggregateOutputType | null
    _sum: MarketSnapshotSumAggregateOutputType | null
    _min: MarketSnapshotMinAggregateOutputType | null
    _max: MarketSnapshotMaxAggregateOutputType | null
  }

  type GetMarketSnapshotGroupByPayload<T extends MarketSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], MarketSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type MarketSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    price?: boolean
    liquidity?: boolean
    volume?: boolean
    marketCap?: boolean
    fdv?: boolean
    priceChange24h?: boolean
    timestamp?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketSnapshot"]>

  export type MarketSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    price?: boolean
    liquidity?: boolean
    volume?: boolean
    marketCap?: boolean
    fdv?: boolean
    priceChange24h?: boolean
    timestamp?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketSnapshot"]>

  export type MarketSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    price?: boolean
    liquidity?: boolean
    volume?: boolean
    marketCap?: boolean
    fdv?: boolean
    priceChange24h?: boolean
    timestamp?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketSnapshot"]>

  export type MarketSnapshotSelectScalar = {
    id?: boolean
    tokenId?: boolean
    price?: boolean
    liquidity?: boolean
    volume?: boolean
    marketCap?: boolean
    fdv?: boolean
    priceChange24h?: boolean
    timestamp?: boolean
  }

  export type MarketSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenId" | "price" | "liquidity" | "volume" | "marketCap" | "fdv" | "priceChange24h" | "timestamp", ExtArgs["result"]["marketSnapshot"]>
  export type MarketSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type MarketSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type MarketSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $MarketSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketSnapshot"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenId: string
      price: Prisma.Decimal
      liquidity: Prisma.Decimal
      volume: Prisma.Decimal
      marketCap: Prisma.Decimal
      fdv: Prisma.Decimal | null
      priceChange24h: Prisma.Decimal | null
      timestamp: Date
    }, ExtArgs["result"]["marketSnapshot"]>
    composites: {}
  }

  type MarketSnapshotGetPayload<S extends boolean | null | undefined | MarketSnapshotDefaultArgs> = $Result.GetResult<Prisma.$MarketSnapshotPayload, S>

  type MarketSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketSnapshotCountAggregateInputType | true
    }

  export interface MarketSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketSnapshot'], meta: { name: 'MarketSnapshot' } }
    /**
     * Find zero or one MarketSnapshot that matches the filter.
     * @param {MarketSnapshotFindUniqueArgs} args - Arguments to find a MarketSnapshot
     * @example
     * // Get one MarketSnapshot
     * const marketSnapshot = await prisma.marketSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketSnapshotFindUniqueArgs>(args: SelectSubset<T, MarketSnapshotFindUniqueArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketSnapshotFindUniqueOrThrowArgs} args - Arguments to find a MarketSnapshot
     * @example
     * // Get one MarketSnapshot
     * const marketSnapshot = await prisma.marketSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotFindFirstArgs} args - Arguments to find a MarketSnapshot
     * @example
     * // Get one MarketSnapshot
     * const marketSnapshot = await prisma.marketSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketSnapshotFindFirstArgs>(args?: SelectSubset<T, MarketSnapshotFindFirstArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotFindFirstOrThrowArgs} args - Arguments to find a MarketSnapshot
     * @example
     * // Get one MarketSnapshot
     * const marketSnapshot = await prisma.marketSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketSnapshots
     * const marketSnapshots = await prisma.marketSnapshot.findMany()
     * 
     * // Get first 10 MarketSnapshots
     * const marketSnapshots = await prisma.marketSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketSnapshotWithIdOnly = await prisma.marketSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketSnapshotFindManyArgs>(args?: SelectSubset<T, MarketSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketSnapshot.
     * @param {MarketSnapshotCreateArgs} args - Arguments to create a MarketSnapshot.
     * @example
     * // Create one MarketSnapshot
     * const MarketSnapshot = await prisma.marketSnapshot.create({
     *   data: {
     *     // ... data to create a MarketSnapshot
     *   }
     * })
     * 
     */
    create<T extends MarketSnapshotCreateArgs>(args: SelectSubset<T, MarketSnapshotCreateArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketSnapshots.
     * @param {MarketSnapshotCreateManyArgs} args - Arguments to create many MarketSnapshots.
     * @example
     * // Create many MarketSnapshots
     * const marketSnapshot = await prisma.marketSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketSnapshotCreateManyArgs>(args?: SelectSubset<T, MarketSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketSnapshots and returns the data saved in the database.
     * @param {MarketSnapshotCreateManyAndReturnArgs} args - Arguments to create many MarketSnapshots.
     * @example
     * // Create many MarketSnapshots
     * const marketSnapshot = await prisma.marketSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketSnapshots and only return the `id`
     * const marketSnapshotWithIdOnly = await prisma.marketSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketSnapshot.
     * @param {MarketSnapshotDeleteArgs} args - Arguments to delete one MarketSnapshot.
     * @example
     * // Delete one MarketSnapshot
     * const MarketSnapshot = await prisma.marketSnapshot.delete({
     *   where: {
     *     // ... filter to delete one MarketSnapshot
     *   }
     * })
     * 
     */
    delete<T extends MarketSnapshotDeleteArgs>(args: SelectSubset<T, MarketSnapshotDeleteArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketSnapshot.
     * @param {MarketSnapshotUpdateArgs} args - Arguments to update one MarketSnapshot.
     * @example
     * // Update one MarketSnapshot
     * const marketSnapshot = await prisma.marketSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketSnapshotUpdateArgs>(args: SelectSubset<T, MarketSnapshotUpdateArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketSnapshots.
     * @param {MarketSnapshotDeleteManyArgs} args - Arguments to filter MarketSnapshots to delete.
     * @example
     * // Delete a few MarketSnapshots
     * const { count } = await prisma.marketSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketSnapshotDeleteManyArgs>(args?: SelectSubset<T, MarketSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketSnapshots
     * const marketSnapshot = await prisma.marketSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketSnapshotUpdateManyArgs>(args: SelectSubset<T, MarketSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketSnapshots and returns the data updated in the database.
     * @param {MarketSnapshotUpdateManyAndReturnArgs} args - Arguments to update many MarketSnapshots.
     * @example
     * // Update many MarketSnapshots
     * const marketSnapshot = await prisma.marketSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketSnapshots and only return the `id`
     * const marketSnapshotWithIdOnly = await prisma.marketSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketSnapshot.
     * @param {MarketSnapshotUpsertArgs} args - Arguments to update or create a MarketSnapshot.
     * @example
     * // Update or create a MarketSnapshot
     * const marketSnapshot = await prisma.marketSnapshot.upsert({
     *   create: {
     *     // ... data to create a MarketSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends MarketSnapshotUpsertArgs>(args: SelectSubset<T, MarketSnapshotUpsertArgs<ExtArgs>>): Prisma__MarketSnapshotClient<$Result.GetResult<Prisma.$MarketSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotCountArgs} args - Arguments to filter MarketSnapshots to count.
     * @example
     * // Count the number of MarketSnapshots
     * const count = await prisma.marketSnapshot.count({
     *   where: {
     *     // ... the filter for the MarketSnapshots we want to count
     *   }
     * })
    **/
    count<T extends MarketSnapshotCountArgs>(
      args?: Subset<T, MarketSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketSnapshotAggregateArgs>(args: Subset<T, MarketSnapshotAggregateArgs>): Prisma.PrismaPromise<GetMarketSnapshotAggregateType<T>>

    /**
     * Group by MarketSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: MarketSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketSnapshot model
   */
  readonly fields: MarketSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketSnapshot model
   */
  interface MarketSnapshotFieldRefs {
    readonly id: FieldRef<"MarketSnapshot", 'String'>
    readonly tokenId: FieldRef<"MarketSnapshot", 'String'>
    readonly price: FieldRef<"MarketSnapshot", 'Decimal'>
    readonly liquidity: FieldRef<"MarketSnapshot", 'Decimal'>
    readonly volume: FieldRef<"MarketSnapshot", 'Decimal'>
    readonly marketCap: FieldRef<"MarketSnapshot", 'Decimal'>
    readonly fdv: FieldRef<"MarketSnapshot", 'Decimal'>
    readonly priceChange24h: FieldRef<"MarketSnapshot", 'Decimal'>
    readonly timestamp: FieldRef<"MarketSnapshot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketSnapshot findUnique
   */
  export type MarketSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MarketSnapshot to fetch.
     */
    where: MarketSnapshotWhereUniqueInput
  }

  /**
   * MarketSnapshot findUniqueOrThrow
   */
  export type MarketSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MarketSnapshot to fetch.
     */
    where: MarketSnapshotWhereUniqueInput
  }

  /**
   * MarketSnapshot findFirst
   */
  export type MarketSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MarketSnapshot to fetch.
     */
    where?: MarketSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSnapshots to fetch.
     */
    orderBy?: MarketSnapshotOrderByWithRelationInput | MarketSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSnapshots.
     */
    cursor?: MarketSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSnapshots.
     */
    distinct?: MarketSnapshotScalarFieldEnum | MarketSnapshotScalarFieldEnum[]
  }

  /**
   * MarketSnapshot findFirstOrThrow
   */
  export type MarketSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MarketSnapshot to fetch.
     */
    where?: MarketSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSnapshots to fetch.
     */
    orderBy?: MarketSnapshotOrderByWithRelationInput | MarketSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketSnapshots.
     */
    cursor?: MarketSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketSnapshots.
     */
    distinct?: MarketSnapshotScalarFieldEnum | MarketSnapshotScalarFieldEnum[]
  }

  /**
   * MarketSnapshot findMany
   */
  export type MarketSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which MarketSnapshots to fetch.
     */
    where?: MarketSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketSnapshots to fetch.
     */
    orderBy?: MarketSnapshotOrderByWithRelationInput | MarketSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketSnapshots.
     */
    cursor?: MarketSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketSnapshots.
     */
    skip?: number
    distinct?: MarketSnapshotScalarFieldEnum | MarketSnapshotScalarFieldEnum[]
  }

  /**
   * MarketSnapshot create
   */
  export type MarketSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketSnapshot.
     */
    data: XOR<MarketSnapshotCreateInput, MarketSnapshotUncheckedCreateInput>
  }

  /**
   * MarketSnapshot createMany
   */
  export type MarketSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketSnapshots.
     */
    data: MarketSnapshotCreateManyInput | MarketSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketSnapshot createManyAndReturn
   */
  export type MarketSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many MarketSnapshots.
     */
    data: MarketSnapshotCreateManyInput | MarketSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketSnapshot update
   */
  export type MarketSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketSnapshot.
     */
    data: XOR<MarketSnapshotUpdateInput, MarketSnapshotUncheckedUpdateInput>
    /**
     * Choose, which MarketSnapshot to update.
     */
    where: MarketSnapshotWhereUniqueInput
  }

  /**
   * MarketSnapshot updateMany
   */
  export type MarketSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketSnapshots.
     */
    data: XOR<MarketSnapshotUpdateManyMutationInput, MarketSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which MarketSnapshots to update
     */
    where?: MarketSnapshotWhereInput
    /**
     * Limit how many MarketSnapshots to update.
     */
    limit?: number
  }

  /**
   * MarketSnapshot updateManyAndReturn
   */
  export type MarketSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update MarketSnapshots.
     */
    data: XOR<MarketSnapshotUpdateManyMutationInput, MarketSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which MarketSnapshots to update
     */
    where?: MarketSnapshotWhereInput
    /**
     * Limit how many MarketSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketSnapshot upsert
   */
  export type MarketSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketSnapshot to update in case it exists.
     */
    where: MarketSnapshotWhereUniqueInput
    /**
     * In case the MarketSnapshot found by the `where` argument doesn't exist, create a new MarketSnapshot with this data.
     */
    create: XOR<MarketSnapshotCreateInput, MarketSnapshotUncheckedCreateInput>
    /**
     * In case the MarketSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketSnapshotUpdateInput, MarketSnapshotUncheckedUpdateInput>
  }

  /**
   * MarketSnapshot delete
   */
  export type MarketSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
    /**
     * Filter which MarketSnapshot to delete.
     */
    where: MarketSnapshotWhereUniqueInput
  }

  /**
   * MarketSnapshot deleteMany
   */
  export type MarketSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketSnapshots to delete
     */
    where?: MarketSnapshotWhereInput
    /**
     * Limit how many MarketSnapshots to delete.
     */
    limit?: number
  }

  /**
   * MarketSnapshot without action
   */
  export type MarketSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketSnapshot
     */
    select?: MarketSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketSnapshot
     */
    omit?: MarketSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model WalletEvent
   */

  export type AggregateWalletEvent = {
    _count: WalletEventCountAggregateOutputType | null
    _avg: WalletEventAvgAggregateOutputType | null
    _sum: WalletEventSumAggregateOutputType | null
    _min: WalletEventMinAggregateOutputType | null
    _max: WalletEventMaxAggregateOutputType | null
  }

  export type WalletEventAvgAggregateOutputType = {
    amount: Decimal | null
    usdValue: Decimal | null
  }

  export type WalletEventSumAggregateOutputType = {
    amount: Decimal | null
    usdValue: Decimal | null
  }

  export type WalletEventMinAggregateOutputType = {
    id: string | null
    tokenId: string | null
    wallet: string | null
    action: string | null
    amount: Decimal | null
    usdValue: Decimal | null
    label: string | null
    timestamp: Date | null
  }

  export type WalletEventMaxAggregateOutputType = {
    id: string | null
    tokenId: string | null
    wallet: string | null
    action: string | null
    amount: Decimal | null
    usdValue: Decimal | null
    label: string | null
    timestamp: Date | null
  }

  export type WalletEventCountAggregateOutputType = {
    id: number
    tokenId: number
    wallet: number
    action: number
    amount: number
    usdValue: number
    label: number
    timestamp: number
    _all: number
  }


  export type WalletEventAvgAggregateInputType = {
    amount?: true
    usdValue?: true
  }

  export type WalletEventSumAggregateInputType = {
    amount?: true
    usdValue?: true
  }

  export type WalletEventMinAggregateInputType = {
    id?: true
    tokenId?: true
    wallet?: true
    action?: true
    amount?: true
    usdValue?: true
    label?: true
    timestamp?: true
  }

  export type WalletEventMaxAggregateInputType = {
    id?: true
    tokenId?: true
    wallet?: true
    action?: true
    amount?: true
    usdValue?: true
    label?: true
    timestamp?: true
  }

  export type WalletEventCountAggregateInputType = {
    id?: true
    tokenId?: true
    wallet?: true
    action?: true
    amount?: true
    usdValue?: true
    label?: true
    timestamp?: true
    _all?: true
  }

  export type WalletEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletEvent to aggregate.
     */
    where?: WalletEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletEvents to fetch.
     */
    orderBy?: WalletEventOrderByWithRelationInput | WalletEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletEvents
    **/
    _count?: true | WalletEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletEventMaxAggregateInputType
  }

  export type GetWalletEventAggregateType<T extends WalletEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletEvent[P]>
      : GetScalarType<T[P], AggregateWalletEvent[P]>
  }




  export type WalletEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletEventWhereInput
    orderBy?: WalletEventOrderByWithAggregationInput | WalletEventOrderByWithAggregationInput[]
    by: WalletEventScalarFieldEnum[] | WalletEventScalarFieldEnum
    having?: WalletEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletEventCountAggregateInputType | true
    _avg?: WalletEventAvgAggregateInputType
    _sum?: WalletEventSumAggregateInputType
    _min?: WalletEventMinAggregateInputType
    _max?: WalletEventMaxAggregateInputType
  }

  export type WalletEventGroupByOutputType = {
    id: string
    tokenId: string
    wallet: string
    action: string
    amount: Decimal
    usdValue: Decimal
    label: string | null
    timestamp: Date
    _count: WalletEventCountAggregateOutputType | null
    _avg: WalletEventAvgAggregateOutputType | null
    _sum: WalletEventSumAggregateOutputType | null
    _min: WalletEventMinAggregateOutputType | null
    _max: WalletEventMaxAggregateOutputType | null
  }

  type GetWalletEventGroupByPayload<T extends WalletEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletEventGroupByOutputType[P]>
            : GetScalarType<T[P], WalletEventGroupByOutputType[P]>
        }
      >
    >


  export type WalletEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    wallet?: boolean
    action?: boolean
    amount?: boolean
    usdValue?: boolean
    label?: boolean
    timestamp?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletEvent"]>

  export type WalletEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    wallet?: boolean
    action?: boolean
    amount?: boolean
    usdValue?: boolean
    label?: boolean
    timestamp?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletEvent"]>

  export type WalletEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    wallet?: boolean
    action?: boolean
    amount?: boolean
    usdValue?: boolean
    label?: boolean
    timestamp?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletEvent"]>

  export type WalletEventSelectScalar = {
    id?: boolean
    tokenId?: boolean
    wallet?: boolean
    action?: boolean
    amount?: boolean
    usdValue?: boolean
    label?: boolean
    timestamp?: boolean
  }

  export type WalletEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenId" | "wallet" | "action" | "amount" | "usdValue" | "label" | "timestamp", ExtArgs["result"]["walletEvent"]>
  export type WalletEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type WalletEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type WalletEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $WalletEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletEvent"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenId: string
      wallet: string
      action: string
      amount: Prisma.Decimal
      usdValue: Prisma.Decimal
      label: string | null
      timestamp: Date
    }, ExtArgs["result"]["walletEvent"]>
    composites: {}
  }

  type WalletEventGetPayload<S extends boolean | null | undefined | WalletEventDefaultArgs> = $Result.GetResult<Prisma.$WalletEventPayload, S>

  type WalletEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletEventCountAggregateInputType | true
    }

  export interface WalletEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletEvent'], meta: { name: 'WalletEvent' } }
    /**
     * Find zero or one WalletEvent that matches the filter.
     * @param {WalletEventFindUniqueArgs} args - Arguments to find a WalletEvent
     * @example
     * // Get one WalletEvent
     * const walletEvent = await prisma.walletEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletEventFindUniqueArgs>(args: SelectSubset<T, WalletEventFindUniqueArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletEventFindUniqueOrThrowArgs} args - Arguments to find a WalletEvent
     * @example
     * // Get one WalletEvent
     * const walletEvent = await prisma.walletEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventFindFirstArgs} args - Arguments to find a WalletEvent
     * @example
     * // Get one WalletEvent
     * const walletEvent = await prisma.walletEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletEventFindFirstArgs>(args?: SelectSubset<T, WalletEventFindFirstArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventFindFirstOrThrowArgs} args - Arguments to find a WalletEvent
     * @example
     * // Get one WalletEvent
     * const walletEvent = await prisma.walletEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletEvents
     * const walletEvents = await prisma.walletEvent.findMany()
     * 
     * // Get first 10 WalletEvents
     * const walletEvents = await prisma.walletEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletEventWithIdOnly = await prisma.walletEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletEventFindManyArgs>(args?: SelectSubset<T, WalletEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletEvent.
     * @param {WalletEventCreateArgs} args - Arguments to create a WalletEvent.
     * @example
     * // Create one WalletEvent
     * const WalletEvent = await prisma.walletEvent.create({
     *   data: {
     *     // ... data to create a WalletEvent
     *   }
     * })
     * 
     */
    create<T extends WalletEventCreateArgs>(args: SelectSubset<T, WalletEventCreateArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletEvents.
     * @param {WalletEventCreateManyArgs} args - Arguments to create many WalletEvents.
     * @example
     * // Create many WalletEvents
     * const walletEvent = await prisma.walletEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletEventCreateManyArgs>(args?: SelectSubset<T, WalletEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletEvents and returns the data saved in the database.
     * @param {WalletEventCreateManyAndReturnArgs} args - Arguments to create many WalletEvents.
     * @example
     * // Create many WalletEvents
     * const walletEvent = await prisma.walletEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletEvents and only return the `id`
     * const walletEventWithIdOnly = await prisma.walletEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletEvent.
     * @param {WalletEventDeleteArgs} args - Arguments to delete one WalletEvent.
     * @example
     * // Delete one WalletEvent
     * const WalletEvent = await prisma.walletEvent.delete({
     *   where: {
     *     // ... filter to delete one WalletEvent
     *   }
     * })
     * 
     */
    delete<T extends WalletEventDeleteArgs>(args: SelectSubset<T, WalletEventDeleteArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletEvent.
     * @param {WalletEventUpdateArgs} args - Arguments to update one WalletEvent.
     * @example
     * // Update one WalletEvent
     * const walletEvent = await prisma.walletEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletEventUpdateArgs>(args: SelectSubset<T, WalletEventUpdateArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletEvents.
     * @param {WalletEventDeleteManyArgs} args - Arguments to filter WalletEvents to delete.
     * @example
     * // Delete a few WalletEvents
     * const { count } = await prisma.walletEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletEventDeleteManyArgs>(args?: SelectSubset<T, WalletEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletEvents
     * const walletEvent = await prisma.walletEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletEventUpdateManyArgs>(args: SelectSubset<T, WalletEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletEvents and returns the data updated in the database.
     * @param {WalletEventUpdateManyAndReturnArgs} args - Arguments to update many WalletEvents.
     * @example
     * // Update many WalletEvents
     * const walletEvent = await prisma.walletEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletEvents and only return the `id`
     * const walletEventWithIdOnly = await prisma.walletEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletEventUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletEvent.
     * @param {WalletEventUpsertArgs} args - Arguments to update or create a WalletEvent.
     * @example
     * // Update or create a WalletEvent
     * const walletEvent = await prisma.walletEvent.upsert({
     *   create: {
     *     // ... data to create a WalletEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletEvent we want to update
     *   }
     * })
     */
    upsert<T extends WalletEventUpsertArgs>(args: SelectSubset<T, WalletEventUpsertArgs<ExtArgs>>): Prisma__WalletEventClient<$Result.GetResult<Prisma.$WalletEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventCountArgs} args - Arguments to filter WalletEvents to count.
     * @example
     * // Count the number of WalletEvents
     * const count = await prisma.walletEvent.count({
     *   where: {
     *     // ... the filter for the WalletEvents we want to count
     *   }
     * })
    **/
    count<T extends WalletEventCountArgs>(
      args?: Subset<T, WalletEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletEventAggregateArgs>(args: Subset<T, WalletEventAggregateArgs>): Prisma.PrismaPromise<GetWalletEventAggregateType<T>>

    /**
     * Group by WalletEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletEventGroupByArgs['orderBy'] }
        : { orderBy?: WalletEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletEvent model
   */
  readonly fields: WalletEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletEvent model
   */
  interface WalletEventFieldRefs {
    readonly id: FieldRef<"WalletEvent", 'String'>
    readonly tokenId: FieldRef<"WalletEvent", 'String'>
    readonly wallet: FieldRef<"WalletEvent", 'String'>
    readonly action: FieldRef<"WalletEvent", 'String'>
    readonly amount: FieldRef<"WalletEvent", 'Decimal'>
    readonly usdValue: FieldRef<"WalletEvent", 'Decimal'>
    readonly label: FieldRef<"WalletEvent", 'String'>
    readonly timestamp: FieldRef<"WalletEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletEvent findUnique
   */
  export type WalletEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * Filter, which WalletEvent to fetch.
     */
    where: WalletEventWhereUniqueInput
  }

  /**
   * WalletEvent findUniqueOrThrow
   */
  export type WalletEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * Filter, which WalletEvent to fetch.
     */
    where: WalletEventWhereUniqueInput
  }

  /**
   * WalletEvent findFirst
   */
  export type WalletEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * Filter, which WalletEvent to fetch.
     */
    where?: WalletEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletEvents to fetch.
     */
    orderBy?: WalletEventOrderByWithRelationInput | WalletEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletEvents.
     */
    cursor?: WalletEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletEvents.
     */
    distinct?: WalletEventScalarFieldEnum | WalletEventScalarFieldEnum[]
  }

  /**
   * WalletEvent findFirstOrThrow
   */
  export type WalletEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * Filter, which WalletEvent to fetch.
     */
    where?: WalletEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletEvents to fetch.
     */
    orderBy?: WalletEventOrderByWithRelationInput | WalletEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletEvents.
     */
    cursor?: WalletEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletEvents.
     */
    distinct?: WalletEventScalarFieldEnum | WalletEventScalarFieldEnum[]
  }

  /**
   * WalletEvent findMany
   */
  export type WalletEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * Filter, which WalletEvents to fetch.
     */
    where?: WalletEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletEvents to fetch.
     */
    orderBy?: WalletEventOrderByWithRelationInput | WalletEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletEvents.
     */
    cursor?: WalletEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletEvents.
     */
    skip?: number
    distinct?: WalletEventScalarFieldEnum | WalletEventScalarFieldEnum[]
  }

  /**
   * WalletEvent create
   */
  export type WalletEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletEvent.
     */
    data: XOR<WalletEventCreateInput, WalletEventUncheckedCreateInput>
  }

  /**
   * WalletEvent createMany
   */
  export type WalletEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletEvents.
     */
    data: WalletEventCreateManyInput | WalletEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletEvent createManyAndReturn
   */
  export type WalletEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * The data used to create many WalletEvents.
     */
    data: WalletEventCreateManyInput | WalletEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletEvent update
   */
  export type WalletEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletEvent.
     */
    data: XOR<WalletEventUpdateInput, WalletEventUncheckedUpdateInput>
    /**
     * Choose, which WalletEvent to update.
     */
    where: WalletEventWhereUniqueInput
  }

  /**
   * WalletEvent updateMany
   */
  export type WalletEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletEvents.
     */
    data: XOR<WalletEventUpdateManyMutationInput, WalletEventUncheckedUpdateManyInput>
    /**
     * Filter which WalletEvents to update
     */
    where?: WalletEventWhereInput
    /**
     * Limit how many WalletEvents to update.
     */
    limit?: number
  }

  /**
   * WalletEvent updateManyAndReturn
   */
  export type WalletEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * The data used to update WalletEvents.
     */
    data: XOR<WalletEventUpdateManyMutationInput, WalletEventUncheckedUpdateManyInput>
    /**
     * Filter which WalletEvents to update
     */
    where?: WalletEventWhereInput
    /**
     * Limit how many WalletEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletEvent upsert
   */
  export type WalletEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletEvent to update in case it exists.
     */
    where: WalletEventWhereUniqueInput
    /**
     * In case the WalletEvent found by the `where` argument doesn't exist, create a new WalletEvent with this data.
     */
    create: XOR<WalletEventCreateInput, WalletEventUncheckedCreateInput>
    /**
     * In case the WalletEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletEventUpdateInput, WalletEventUncheckedUpdateInput>
  }

  /**
   * WalletEvent delete
   */
  export type WalletEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
    /**
     * Filter which WalletEvent to delete.
     */
    where: WalletEventWhereUniqueInput
  }

  /**
   * WalletEvent deleteMany
   */
  export type WalletEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletEvents to delete
     */
    where?: WalletEventWhereInput
    /**
     * Limit how many WalletEvents to delete.
     */
    limit?: number
  }

  /**
   * WalletEvent without action
   */
  export type WalletEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletEvent
     */
    select?: WalletEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletEvent
     */
    omit?: WalletEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletEventInclude<ExtArgs> | null
  }


  /**
   * Model Signal
   */

  export type AggregateSignal = {
    _count: SignalCountAggregateOutputType | null
    _avg: SignalAvgAggregateOutputType | null
    _sum: SignalSumAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  export type SignalAvgAggregateOutputType = {
    convictionScore: number | null
    smartMoneyScore: number | null
    whaleScore: number | null
    edgeScore: number | null
    confidence: number | null
  }

  export type SignalSumAggregateOutputType = {
    convictionScore: number | null
    smartMoneyScore: number | null
    whaleScore: number | null
    edgeScore: number | null
    confidence: number | null
  }

  export type SignalMinAggregateOutputType = {
    tokenId: string | null
    convictionScore: number | null
    smartMoneyScore: number | null
    whaleScore: number | null
    edgeScore: number | null
    momentumPhase: string | null
    threatLevel: string | null
    edgeVerdict: string | null
    confidence: number | null
    updatedAt: Date | null
  }

  export type SignalMaxAggregateOutputType = {
    tokenId: string | null
    convictionScore: number | null
    smartMoneyScore: number | null
    whaleScore: number | null
    edgeScore: number | null
    momentumPhase: string | null
    threatLevel: string | null
    edgeVerdict: string | null
    confidence: number | null
    updatedAt: Date | null
  }

  export type SignalCountAggregateOutputType = {
    tokenId: number
    convictionScore: number
    smartMoneyScore: number
    whaleScore: number
    edgeScore: number
    momentumPhase: number
    threatLevel: number
    edgeVerdict: number
    confidence: number
    updatedAt: number
    _all: number
  }


  export type SignalAvgAggregateInputType = {
    convictionScore?: true
    smartMoneyScore?: true
    whaleScore?: true
    edgeScore?: true
    confidence?: true
  }

  export type SignalSumAggregateInputType = {
    convictionScore?: true
    smartMoneyScore?: true
    whaleScore?: true
    edgeScore?: true
    confidence?: true
  }

  export type SignalMinAggregateInputType = {
    tokenId?: true
    convictionScore?: true
    smartMoneyScore?: true
    whaleScore?: true
    edgeScore?: true
    momentumPhase?: true
    threatLevel?: true
    edgeVerdict?: true
    confidence?: true
    updatedAt?: true
  }

  export type SignalMaxAggregateInputType = {
    tokenId?: true
    convictionScore?: true
    smartMoneyScore?: true
    whaleScore?: true
    edgeScore?: true
    momentumPhase?: true
    threatLevel?: true
    edgeVerdict?: true
    confidence?: true
    updatedAt?: true
  }

  export type SignalCountAggregateInputType = {
    tokenId?: true
    convictionScore?: true
    smartMoneyScore?: true
    whaleScore?: true
    edgeScore?: true
    momentumPhase?: true
    threatLevel?: true
    edgeVerdict?: true
    confidence?: true
    updatedAt?: true
    _all?: true
  }

  export type SignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signal to aggregate.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signals
    **/
    _count?: true | SignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalMaxAggregateInputType
  }

  export type GetSignalAggregateType<T extends SignalAggregateArgs> = {
        [P in keyof T & keyof AggregateSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignal[P]>
      : GetScalarType<T[P], AggregateSignal[P]>
  }




  export type SignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithAggregationInput | SignalOrderByWithAggregationInput[]
    by: SignalScalarFieldEnum[] | SignalScalarFieldEnum
    having?: SignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalCountAggregateInputType | true
    _avg?: SignalAvgAggregateInputType
    _sum?: SignalSumAggregateInputType
    _min?: SignalMinAggregateInputType
    _max?: SignalMaxAggregateInputType
  }

  export type SignalGroupByOutputType = {
    tokenId: string
    convictionScore: number
    smartMoneyScore: number
    whaleScore: number
    edgeScore: number
    momentumPhase: string
    threatLevel: string
    edgeVerdict: string
    confidence: number
    updatedAt: Date
    _count: SignalCountAggregateOutputType | null
    _avg: SignalAvgAggregateOutputType | null
    _sum: SignalSumAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  type GetSignalGroupByPayload<T extends SignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalGroupByOutputType[P]>
            : GetScalarType<T[P], SignalGroupByOutputType[P]>
        }
      >
    >


  export type SignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tokenId?: boolean
    convictionScore?: boolean
    smartMoneyScore?: boolean
    whaleScore?: boolean
    edgeScore?: boolean
    momentumPhase?: boolean
    threatLevel?: boolean
    edgeVerdict?: boolean
    confidence?: boolean
    updatedAt?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tokenId?: boolean
    convictionScore?: boolean
    smartMoneyScore?: boolean
    whaleScore?: boolean
    edgeScore?: boolean
    momentumPhase?: boolean
    threatLevel?: boolean
    edgeVerdict?: boolean
    confidence?: boolean
    updatedAt?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tokenId?: boolean
    convictionScore?: boolean
    smartMoneyScore?: boolean
    whaleScore?: boolean
    edgeScore?: boolean
    momentumPhase?: boolean
    threatLevel?: boolean
    edgeVerdict?: boolean
    confidence?: boolean
    updatedAt?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>

  export type SignalSelectScalar = {
    tokenId?: boolean
    convictionScore?: boolean
    smartMoneyScore?: boolean
    whaleScore?: boolean
    edgeScore?: boolean
    momentumPhase?: boolean
    threatLevel?: boolean
    edgeVerdict?: boolean
    confidence?: boolean
    updatedAt?: boolean
  }

  export type SignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tokenId" | "convictionScore" | "smartMoneyScore" | "whaleScore" | "edgeScore" | "momentumPhase" | "threatLevel" | "edgeVerdict" | "confidence" | "updatedAt", ExtArgs["result"]["signal"]>
  export type SignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type SignalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type SignalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $SignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signal"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tokenId: string
      convictionScore: number
      smartMoneyScore: number
      whaleScore: number
      edgeScore: number
      momentumPhase: string
      threatLevel: string
      edgeVerdict: string
      confidence: number
      updatedAt: Date
    }, ExtArgs["result"]["signal"]>
    composites: {}
  }

  type SignalGetPayload<S extends boolean | null | undefined | SignalDefaultArgs> = $Result.GetResult<Prisma.$SignalPayload, S>

  type SignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignalCountAggregateInputType | true
    }

  export interface SignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signal'], meta: { name: 'Signal' } }
    /**
     * Find zero or one Signal that matches the filter.
     * @param {SignalFindUniqueArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalFindUniqueArgs>(args: SelectSubset<T, SignalFindUniqueArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignalFindUniqueOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalFindFirstArgs>(args?: SelectSubset<T, SignalFindFirstArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signals
     * const signals = await prisma.signal.findMany()
     * 
     * // Get first 10 Signals
     * const signals = await prisma.signal.findMany({ take: 10 })
     * 
     * // Only select the `tokenId`
     * const signalWithTokenIdOnly = await prisma.signal.findMany({ select: { tokenId: true } })
     * 
     */
    findMany<T extends SignalFindManyArgs>(args?: SelectSubset<T, SignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signal.
     * @param {SignalCreateArgs} args - Arguments to create a Signal.
     * @example
     * // Create one Signal
     * const Signal = await prisma.signal.create({
     *   data: {
     *     // ... data to create a Signal
     *   }
     * })
     * 
     */
    create<T extends SignalCreateArgs>(args: SelectSubset<T, SignalCreateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signals.
     * @param {SignalCreateManyArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalCreateManyArgs>(args?: SelectSubset<T, SignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signals and returns the data saved in the database.
     * @param {SignalCreateManyAndReturnArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signals and only return the `tokenId`
     * const signalWithTokenIdOnly = await prisma.signal.createManyAndReturn({
     *   select: { tokenId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SignalCreateManyAndReturnArgs>(args?: SelectSubset<T, SignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signal.
     * @param {SignalDeleteArgs} args - Arguments to delete one Signal.
     * @example
     * // Delete one Signal
     * const Signal = await prisma.signal.delete({
     *   where: {
     *     // ... filter to delete one Signal
     *   }
     * })
     * 
     */
    delete<T extends SignalDeleteArgs>(args: SelectSubset<T, SignalDeleteArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signal.
     * @param {SignalUpdateArgs} args - Arguments to update one Signal.
     * @example
     * // Update one Signal
     * const signal = await prisma.signal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalUpdateArgs>(args: SelectSubset<T, SignalUpdateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signals.
     * @param {SignalDeleteManyArgs} args - Arguments to filter Signals to delete.
     * @example
     * // Delete a few Signals
     * const { count } = await prisma.signal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalDeleteManyArgs>(args?: SelectSubset<T, SignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalUpdateManyArgs>(args: SelectSubset<T, SignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals and returns the data updated in the database.
     * @param {SignalUpdateManyAndReturnArgs} args - Arguments to update many Signals.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signals and only return the `tokenId`
     * const signalWithTokenIdOnly = await prisma.signal.updateManyAndReturn({
     *   select: { tokenId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SignalUpdateManyAndReturnArgs>(args: SelectSubset<T, SignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signal.
     * @param {SignalUpsertArgs} args - Arguments to update or create a Signal.
     * @example
     * // Update or create a Signal
     * const signal = await prisma.signal.upsert({
     *   create: {
     *     // ... data to create a Signal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signal we want to update
     *   }
     * })
     */
    upsert<T extends SignalUpsertArgs>(args: SelectSubset<T, SignalUpsertArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalCountArgs} args - Arguments to filter Signals to count.
     * @example
     * // Count the number of Signals
     * const count = await prisma.signal.count({
     *   where: {
     *     // ... the filter for the Signals we want to count
     *   }
     * })
    **/
    count<T extends SignalCountArgs>(
      args?: Subset<T, SignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalAggregateArgs>(args: Subset<T, SignalAggregateArgs>): Prisma.PrismaPromise<GetSignalAggregateType<T>>

    /**
     * Group by Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalGroupByArgs['orderBy'] }
        : { orderBy?: SignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signal model
   */
  readonly fields: SignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signal model
   */
  interface SignalFieldRefs {
    readonly tokenId: FieldRef<"Signal", 'String'>
    readonly convictionScore: FieldRef<"Signal", 'Int'>
    readonly smartMoneyScore: FieldRef<"Signal", 'Int'>
    readonly whaleScore: FieldRef<"Signal", 'Int'>
    readonly edgeScore: FieldRef<"Signal", 'Int'>
    readonly momentumPhase: FieldRef<"Signal", 'String'>
    readonly threatLevel: FieldRef<"Signal", 'String'>
    readonly edgeVerdict: FieldRef<"Signal", 'String'>
    readonly confidence: FieldRef<"Signal", 'Int'>
    readonly updatedAt: FieldRef<"Signal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Signal findUnique
   */
  export type SignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findUniqueOrThrow
   */
  export type SignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findFirst
   */
  export type SignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findFirstOrThrow
   */
  export type SignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findMany
   */
  export type SignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signals to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal create
   */
  export type SignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The data needed to create a Signal.
     */
    data: XOR<SignalCreateInput, SignalUncheckedCreateInput>
  }

  /**
   * Signal createMany
   */
  export type SignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signal createManyAndReturn
   */
  export type SignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signal update
   */
  export type SignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The data needed to update a Signal.
     */
    data: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
    /**
     * Choose, which Signal to update.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal updateMany
   */
  export type SignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
  }

  /**
   * Signal updateManyAndReturn
   */
  export type SignalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Signal upsert
   */
  export type SignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The filter to search for the Signal to update in case it exists.
     */
    where: SignalWhereUniqueInput
    /**
     * In case the Signal found by the `where` argument doesn't exist, create a new Signal with this data.
     */
    create: XOR<SignalCreateInput, SignalUncheckedCreateInput>
    /**
     * In case the Signal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
  }

  /**
   * Signal delete
   */
  export type SignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter which Signal to delete.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal deleteMany
   */
  export type SignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signals to delete
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to delete.
     */
    limit?: number
  }

  /**
   * Signal without action
   */
  export type SignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amountUsd: Decimal | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amountUsd: Decimal | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    tokenId: string | null
    walletAddress: string | null
    amountUsd: Decimal | null
    side: string | null
    timestamp: Date | null
    signature: string | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    tokenId: string | null
    walletAddress: string | null
    amountUsd: Decimal | null
    side: string | null
    timestamp: Date | null
    signature: string | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    tokenId: number
    walletAddress: number
    amountUsd: number
    side: number
    timestamp: number
    signature: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amountUsd?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amountUsd?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    tokenId?: true
    walletAddress?: true
    amountUsd?: true
    side?: true
    timestamp?: true
    signature?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    tokenId?: true
    walletAddress?: true
    amountUsd?: true
    side?: true
    timestamp?: true
    signature?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    tokenId?: true
    walletAddress?: true
    amountUsd?: true
    side?: true
    timestamp?: true
    signature?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    tokenId: string
    walletAddress: string
    amountUsd: Decimal
    side: string
    timestamp: Date
    signature: string
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    walletAddress?: boolean
    amountUsd?: boolean
    side?: boolean
    timestamp?: boolean
    signature?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    walletAddress?: boolean
    amountUsd?: boolean
    side?: boolean
    timestamp?: boolean
    signature?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    walletAddress?: boolean
    amountUsd?: boolean
    side?: boolean
    timestamp?: boolean
    signature?: boolean
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    tokenId?: boolean
    walletAddress?: boolean
    amountUsd?: boolean
    side?: boolean
    timestamp?: boolean
    signature?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenId" | "walletAddress" | "amountUsd" | "side" | "timestamp" | "signature", ExtArgs["result"]["walletTransaction"]>
  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type WalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }
  export type WalletTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    token?: boolean | TokenDefaultArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      token: Prisma.$TokenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenId: string
      walletAddress: string
      amountUsd: Prisma.Decimal
      side: string
      timestamp: Date
      signature: string
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions and returns the data updated in the database.
     * @param {WalletTransactionUpdateManyAndReturnArgs} args - Arguments to update many WalletTransactions.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    token<T extends TokenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TokenDefaultArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly tokenId: FieldRef<"WalletTransaction", 'String'>
    readonly walletAddress: FieldRef<"WalletTransaction", 'String'>
    readonly amountUsd: FieldRef<"WalletTransaction", 'Decimal'>
    readonly side: FieldRef<"WalletTransaction", 'String'>
    readonly timestamp: FieldRef<"WalletTransaction", 'DateTime'>
    readonly signature: FieldRef<"WalletTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction updateManyAndReturn
   */
  export type WalletTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model SmartWallet
   */

  export type AggregateSmartWallet = {
    _count: SmartWalletCountAggregateOutputType | null
    _avg: SmartWalletAvgAggregateOutputType | null
    _sum: SmartWalletSumAggregateOutputType | null
    _min: SmartWalletMinAggregateOutputType | null
    _max: SmartWalletMaxAggregateOutputType | null
  }

  export type SmartWalletAvgAggregateOutputType = {
    smartScore: number | null
    totalWins: number | null
    totalTrades: number | null
    avgEntryPosition: Decimal | null
  }

  export type SmartWalletSumAggregateOutputType = {
    smartScore: number | null
    totalWins: number | null
    totalTrades: number | null
    avgEntryPosition: Decimal | null
  }

  export type SmartWalletMinAggregateOutputType = {
    walletAddress: string | null
    smartScore: number | null
    totalWins: number | null
    totalTrades: number | null
    avgEntryPosition: Decimal | null
    lastActive: Date | null
  }

  export type SmartWalletMaxAggregateOutputType = {
    walletAddress: string | null
    smartScore: number | null
    totalWins: number | null
    totalTrades: number | null
    avgEntryPosition: Decimal | null
    lastActive: Date | null
  }

  export type SmartWalletCountAggregateOutputType = {
    walletAddress: number
    smartScore: number
    totalWins: number
    totalTrades: number
    avgEntryPosition: number
    lastActive: number
    _all: number
  }


  export type SmartWalletAvgAggregateInputType = {
    smartScore?: true
    totalWins?: true
    totalTrades?: true
    avgEntryPosition?: true
  }

  export type SmartWalletSumAggregateInputType = {
    smartScore?: true
    totalWins?: true
    totalTrades?: true
    avgEntryPosition?: true
  }

  export type SmartWalletMinAggregateInputType = {
    walletAddress?: true
    smartScore?: true
    totalWins?: true
    totalTrades?: true
    avgEntryPosition?: true
    lastActive?: true
  }

  export type SmartWalletMaxAggregateInputType = {
    walletAddress?: true
    smartScore?: true
    totalWins?: true
    totalTrades?: true
    avgEntryPosition?: true
    lastActive?: true
  }

  export type SmartWalletCountAggregateInputType = {
    walletAddress?: true
    smartScore?: true
    totalWins?: true
    totalTrades?: true
    avgEntryPosition?: true
    lastActive?: true
    _all?: true
  }

  export type SmartWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmartWallet to aggregate.
     */
    where?: SmartWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartWallets to fetch.
     */
    orderBy?: SmartWalletOrderByWithRelationInput | SmartWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmartWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmartWallets
    **/
    _count?: true | SmartWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmartWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmartWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmartWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmartWalletMaxAggregateInputType
  }

  export type GetSmartWalletAggregateType<T extends SmartWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateSmartWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmartWallet[P]>
      : GetScalarType<T[P], AggregateSmartWallet[P]>
  }




  export type SmartWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmartWalletWhereInput
    orderBy?: SmartWalletOrderByWithAggregationInput | SmartWalletOrderByWithAggregationInput[]
    by: SmartWalletScalarFieldEnum[] | SmartWalletScalarFieldEnum
    having?: SmartWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmartWalletCountAggregateInputType | true
    _avg?: SmartWalletAvgAggregateInputType
    _sum?: SmartWalletSumAggregateInputType
    _min?: SmartWalletMinAggregateInputType
    _max?: SmartWalletMaxAggregateInputType
  }

  export type SmartWalletGroupByOutputType = {
    walletAddress: string
    smartScore: number
    totalWins: number
    totalTrades: number
    avgEntryPosition: Decimal
    lastActive: Date
    _count: SmartWalletCountAggregateOutputType | null
    _avg: SmartWalletAvgAggregateOutputType | null
    _sum: SmartWalletSumAggregateOutputType | null
    _min: SmartWalletMinAggregateOutputType | null
    _max: SmartWalletMaxAggregateOutputType | null
  }

  type GetSmartWalletGroupByPayload<T extends SmartWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmartWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmartWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmartWalletGroupByOutputType[P]>
            : GetScalarType<T[P], SmartWalletGroupByOutputType[P]>
        }
      >
    >


  export type SmartWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    walletAddress?: boolean
    smartScore?: boolean
    totalWins?: boolean
    totalTrades?: boolean
    avgEntryPosition?: boolean
    lastActive?: boolean
  }, ExtArgs["result"]["smartWallet"]>

  export type SmartWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    walletAddress?: boolean
    smartScore?: boolean
    totalWins?: boolean
    totalTrades?: boolean
    avgEntryPosition?: boolean
    lastActive?: boolean
  }, ExtArgs["result"]["smartWallet"]>

  export type SmartWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    walletAddress?: boolean
    smartScore?: boolean
    totalWins?: boolean
    totalTrades?: boolean
    avgEntryPosition?: boolean
    lastActive?: boolean
  }, ExtArgs["result"]["smartWallet"]>

  export type SmartWalletSelectScalar = {
    walletAddress?: boolean
    smartScore?: boolean
    totalWins?: boolean
    totalTrades?: boolean
    avgEntryPosition?: boolean
    lastActive?: boolean
  }

  export type SmartWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"walletAddress" | "smartScore" | "totalWins" | "totalTrades" | "avgEntryPosition" | "lastActive", ExtArgs["result"]["smartWallet"]>

  export type $SmartWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SmartWallet"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      walletAddress: string
      smartScore: number
      totalWins: number
      totalTrades: number
      avgEntryPosition: Prisma.Decimal
      lastActive: Date
    }, ExtArgs["result"]["smartWallet"]>
    composites: {}
  }

  type SmartWalletGetPayload<S extends boolean | null | undefined | SmartWalletDefaultArgs> = $Result.GetResult<Prisma.$SmartWalletPayload, S>

  type SmartWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SmartWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SmartWalletCountAggregateInputType | true
    }

  export interface SmartWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SmartWallet'], meta: { name: 'SmartWallet' } }
    /**
     * Find zero or one SmartWallet that matches the filter.
     * @param {SmartWalletFindUniqueArgs} args - Arguments to find a SmartWallet
     * @example
     * // Get one SmartWallet
     * const smartWallet = await prisma.smartWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmartWalletFindUniqueArgs>(args: SelectSubset<T, SmartWalletFindUniqueArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SmartWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SmartWalletFindUniqueOrThrowArgs} args - Arguments to find a SmartWallet
     * @example
     * // Get one SmartWallet
     * const smartWallet = await prisma.smartWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmartWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, SmartWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmartWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletFindFirstArgs} args - Arguments to find a SmartWallet
     * @example
     * // Get one SmartWallet
     * const smartWallet = await prisma.smartWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmartWalletFindFirstArgs>(args?: SelectSubset<T, SmartWalletFindFirstArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmartWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletFindFirstOrThrowArgs} args - Arguments to find a SmartWallet
     * @example
     * // Get one SmartWallet
     * const smartWallet = await prisma.smartWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmartWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, SmartWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SmartWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmartWallets
     * const smartWallets = await prisma.smartWallet.findMany()
     * 
     * // Get first 10 SmartWallets
     * const smartWallets = await prisma.smartWallet.findMany({ take: 10 })
     * 
     * // Only select the `walletAddress`
     * const smartWalletWithWalletAddressOnly = await prisma.smartWallet.findMany({ select: { walletAddress: true } })
     * 
     */
    findMany<T extends SmartWalletFindManyArgs>(args?: SelectSubset<T, SmartWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SmartWallet.
     * @param {SmartWalletCreateArgs} args - Arguments to create a SmartWallet.
     * @example
     * // Create one SmartWallet
     * const SmartWallet = await prisma.smartWallet.create({
     *   data: {
     *     // ... data to create a SmartWallet
     *   }
     * })
     * 
     */
    create<T extends SmartWalletCreateArgs>(args: SelectSubset<T, SmartWalletCreateArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SmartWallets.
     * @param {SmartWalletCreateManyArgs} args - Arguments to create many SmartWallets.
     * @example
     * // Create many SmartWallets
     * const smartWallet = await prisma.smartWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SmartWalletCreateManyArgs>(args?: SelectSubset<T, SmartWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SmartWallets and returns the data saved in the database.
     * @param {SmartWalletCreateManyAndReturnArgs} args - Arguments to create many SmartWallets.
     * @example
     * // Create many SmartWallets
     * const smartWallet = await prisma.smartWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SmartWallets and only return the `walletAddress`
     * const smartWalletWithWalletAddressOnly = await prisma.smartWallet.createManyAndReturn({
     *   select: { walletAddress: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SmartWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, SmartWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SmartWallet.
     * @param {SmartWalletDeleteArgs} args - Arguments to delete one SmartWallet.
     * @example
     * // Delete one SmartWallet
     * const SmartWallet = await prisma.smartWallet.delete({
     *   where: {
     *     // ... filter to delete one SmartWallet
     *   }
     * })
     * 
     */
    delete<T extends SmartWalletDeleteArgs>(args: SelectSubset<T, SmartWalletDeleteArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SmartWallet.
     * @param {SmartWalletUpdateArgs} args - Arguments to update one SmartWallet.
     * @example
     * // Update one SmartWallet
     * const smartWallet = await prisma.smartWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SmartWalletUpdateArgs>(args: SelectSubset<T, SmartWalletUpdateArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SmartWallets.
     * @param {SmartWalletDeleteManyArgs} args - Arguments to filter SmartWallets to delete.
     * @example
     * // Delete a few SmartWallets
     * const { count } = await prisma.smartWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SmartWalletDeleteManyArgs>(args?: SelectSubset<T, SmartWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmartWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmartWallets
     * const smartWallet = await prisma.smartWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SmartWalletUpdateManyArgs>(args: SelectSubset<T, SmartWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmartWallets and returns the data updated in the database.
     * @param {SmartWalletUpdateManyAndReturnArgs} args - Arguments to update many SmartWallets.
     * @example
     * // Update many SmartWallets
     * const smartWallet = await prisma.smartWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SmartWallets and only return the `walletAddress`
     * const smartWalletWithWalletAddressOnly = await prisma.smartWallet.updateManyAndReturn({
     *   select: { walletAddress: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SmartWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, SmartWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SmartWallet.
     * @param {SmartWalletUpsertArgs} args - Arguments to update or create a SmartWallet.
     * @example
     * // Update or create a SmartWallet
     * const smartWallet = await prisma.smartWallet.upsert({
     *   create: {
     *     // ... data to create a SmartWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmartWallet we want to update
     *   }
     * })
     */
    upsert<T extends SmartWalletUpsertArgs>(args: SelectSubset<T, SmartWalletUpsertArgs<ExtArgs>>): Prisma__SmartWalletClient<$Result.GetResult<Prisma.$SmartWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SmartWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletCountArgs} args - Arguments to filter SmartWallets to count.
     * @example
     * // Count the number of SmartWallets
     * const count = await prisma.smartWallet.count({
     *   where: {
     *     // ... the filter for the SmartWallets we want to count
     *   }
     * })
    **/
    count<T extends SmartWalletCountArgs>(
      args?: Subset<T, SmartWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmartWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmartWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmartWalletAggregateArgs>(args: Subset<T, SmartWalletAggregateArgs>): Prisma.PrismaPromise<GetSmartWalletAggregateType<T>>

    /**
     * Group by SmartWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmartWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmartWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmartWalletGroupByArgs['orderBy'] }
        : { orderBy?: SmartWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmartWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmartWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SmartWallet model
   */
  readonly fields: SmartWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmartWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmartWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SmartWallet model
   */
  interface SmartWalletFieldRefs {
    readonly walletAddress: FieldRef<"SmartWallet", 'String'>
    readonly smartScore: FieldRef<"SmartWallet", 'Int'>
    readonly totalWins: FieldRef<"SmartWallet", 'Int'>
    readonly totalTrades: FieldRef<"SmartWallet", 'Int'>
    readonly avgEntryPosition: FieldRef<"SmartWallet", 'Decimal'>
    readonly lastActive: FieldRef<"SmartWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SmartWallet findUnique
   */
  export type SmartWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * Filter, which SmartWallet to fetch.
     */
    where: SmartWalletWhereUniqueInput
  }

  /**
   * SmartWallet findUniqueOrThrow
   */
  export type SmartWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * Filter, which SmartWallet to fetch.
     */
    where: SmartWalletWhereUniqueInput
  }

  /**
   * SmartWallet findFirst
   */
  export type SmartWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * Filter, which SmartWallet to fetch.
     */
    where?: SmartWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartWallets to fetch.
     */
    orderBy?: SmartWalletOrderByWithRelationInput | SmartWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmartWallets.
     */
    cursor?: SmartWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmartWallets.
     */
    distinct?: SmartWalletScalarFieldEnum | SmartWalletScalarFieldEnum[]
  }

  /**
   * SmartWallet findFirstOrThrow
   */
  export type SmartWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * Filter, which SmartWallet to fetch.
     */
    where?: SmartWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartWallets to fetch.
     */
    orderBy?: SmartWalletOrderByWithRelationInput | SmartWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmartWallets.
     */
    cursor?: SmartWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmartWallets.
     */
    distinct?: SmartWalletScalarFieldEnum | SmartWalletScalarFieldEnum[]
  }

  /**
   * SmartWallet findMany
   */
  export type SmartWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * Filter, which SmartWallets to fetch.
     */
    where?: SmartWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmartWallets to fetch.
     */
    orderBy?: SmartWalletOrderByWithRelationInput | SmartWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmartWallets.
     */
    cursor?: SmartWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmartWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmartWallets.
     */
    skip?: number
    distinct?: SmartWalletScalarFieldEnum | SmartWalletScalarFieldEnum[]
  }

  /**
   * SmartWallet create
   */
  export type SmartWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * The data needed to create a SmartWallet.
     */
    data: XOR<SmartWalletCreateInput, SmartWalletUncheckedCreateInput>
  }

  /**
   * SmartWallet createMany
   */
  export type SmartWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SmartWallets.
     */
    data: SmartWalletCreateManyInput | SmartWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmartWallet createManyAndReturn
   */
  export type SmartWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * The data used to create many SmartWallets.
     */
    data: SmartWalletCreateManyInput | SmartWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmartWallet update
   */
  export type SmartWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * The data needed to update a SmartWallet.
     */
    data: XOR<SmartWalletUpdateInput, SmartWalletUncheckedUpdateInput>
    /**
     * Choose, which SmartWallet to update.
     */
    where: SmartWalletWhereUniqueInput
  }

  /**
   * SmartWallet updateMany
   */
  export type SmartWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SmartWallets.
     */
    data: XOR<SmartWalletUpdateManyMutationInput, SmartWalletUncheckedUpdateManyInput>
    /**
     * Filter which SmartWallets to update
     */
    where?: SmartWalletWhereInput
    /**
     * Limit how many SmartWallets to update.
     */
    limit?: number
  }

  /**
   * SmartWallet updateManyAndReturn
   */
  export type SmartWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * The data used to update SmartWallets.
     */
    data: XOR<SmartWalletUpdateManyMutationInput, SmartWalletUncheckedUpdateManyInput>
    /**
     * Filter which SmartWallets to update
     */
    where?: SmartWalletWhereInput
    /**
     * Limit how many SmartWallets to update.
     */
    limit?: number
  }

  /**
   * SmartWallet upsert
   */
  export type SmartWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * The filter to search for the SmartWallet to update in case it exists.
     */
    where: SmartWalletWhereUniqueInput
    /**
     * In case the SmartWallet found by the `where` argument doesn't exist, create a new SmartWallet with this data.
     */
    create: XOR<SmartWalletCreateInput, SmartWalletUncheckedCreateInput>
    /**
     * In case the SmartWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmartWalletUpdateInput, SmartWalletUncheckedUpdateInput>
  }

  /**
   * SmartWallet delete
   */
  export type SmartWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
    /**
     * Filter which SmartWallet to delete.
     */
    where: SmartWalletWhereUniqueInput
  }

  /**
   * SmartWallet deleteMany
   */
  export type SmartWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmartWallets to delete
     */
    where?: SmartWalletWhereInput
    /**
     * Limit how many SmartWallets to delete.
     */
    limit?: number
  }

  /**
   * SmartWallet without action
   */
  export type SmartWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmartWallet
     */
    select?: SmartWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmartWallet
     */
    omit?: SmartWalletOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TokenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ticker: 'ticker',
    contract: 'contract',
    chain: 'chain',
    pairAddress: 'pairAddress',
    dexId: 'dexId',
    logoUrl: 'logoUrl',
    price: 'price',
    liquidity: 'liquidity',
    volume24h: 'volume24h',
    marketCap: 'marketCap',
    createdAt: 'createdAt',
    firstSeenAt: 'firstSeenAt',
    lastSeenAt: 'lastSeenAt',
    pairCreatedAt: 'pairCreatedAt',
    lastIngestedAt: 'lastIngestedAt',
    momentumScore: 'momentumScore',
    convictionScore: 'convictionScore',
    threatLevel: 'threatLevel',
    smartWalletFlow: 'smartWalletFlow',
    clusterDetected: 'clusterDetected',
    aiSummary: 'aiSummary',
    aiSummaryUpdated: 'aiSummaryUpdated'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const MarketSnapshotScalarFieldEnum: {
    id: 'id',
    tokenId: 'tokenId',
    price: 'price',
    liquidity: 'liquidity',
    volume: 'volume',
    marketCap: 'marketCap',
    fdv: 'fdv',
    priceChange24h: 'priceChange24h',
    timestamp: 'timestamp'
  };

  export type MarketSnapshotScalarFieldEnum = (typeof MarketSnapshotScalarFieldEnum)[keyof typeof MarketSnapshotScalarFieldEnum]


  export const WalletEventScalarFieldEnum: {
    id: 'id',
    tokenId: 'tokenId',
    wallet: 'wallet',
    action: 'action',
    amount: 'amount',
    usdValue: 'usdValue',
    label: 'label',
    timestamp: 'timestamp'
  };

  export type WalletEventScalarFieldEnum = (typeof WalletEventScalarFieldEnum)[keyof typeof WalletEventScalarFieldEnum]


  export const SignalScalarFieldEnum: {
    tokenId: 'tokenId',
    convictionScore: 'convictionScore',
    smartMoneyScore: 'smartMoneyScore',
    whaleScore: 'whaleScore',
    edgeScore: 'edgeScore',
    momentumPhase: 'momentumPhase',
    threatLevel: 'threatLevel',
    edgeVerdict: 'edgeVerdict',
    confidence: 'confidence',
    updatedAt: 'updatedAt'
  };

  export type SignalScalarFieldEnum = (typeof SignalScalarFieldEnum)[keyof typeof SignalScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    tokenId: 'tokenId',
    walletAddress: 'walletAddress',
    amountUsd: 'amountUsd',
    side: 'side',
    timestamp: 'timestamp',
    signature: 'signature'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const SmartWalletScalarFieldEnum: {
    walletAddress: 'walletAddress',
    smartScore: 'smartScore',
    totalWins: 'totalWins',
    totalTrades: 'totalTrades',
    avgEntryPosition: 'avgEntryPosition',
    lastActive: 'lastActive'
  };

  export type SmartWalletScalarFieldEnum = (typeof SmartWalletScalarFieldEnum)[keyof typeof SmartWalletScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    name?: StringFilter<"Token"> | string
    ticker?: StringFilter<"Token"> | string
    contract?: StringFilter<"Token"> | string
    chain?: StringFilter<"Token"> | string
    pairAddress?: StringNullableFilter<"Token"> | string | null
    dexId?: StringNullableFilter<"Token"> | string | null
    logoUrl?: StringNullableFilter<"Token"> | string | null
    price?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    firstSeenAt?: DateTimeFilter<"Token"> | Date | string
    lastSeenAt?: DateTimeFilter<"Token"> | Date | string
    pairCreatedAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    lastIngestedAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    momentumScore?: IntFilter<"Token"> | number
    convictionScore?: IntFilter<"Token"> | number
    threatLevel?: StringFilter<"Token"> | string
    smartWalletFlow?: BoolFilter<"Token"> | boolean
    clusterDetected?: BoolFilter<"Token"> | boolean
    aiSummary?: StringNullableFilter<"Token"> | string | null
    aiSummaryUpdated?: DateTimeNullableFilter<"Token"> | Date | string | null
    snapshots?: MarketSnapshotListRelationFilter
    walletEvents?: WalletEventListRelationFilter
    transactions?: WalletTransactionListRelationFilter
    signal?: XOR<SignalNullableScalarRelationFilter, SignalWhereInput> | null
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    contract?: SortOrder
    chain?: SortOrder
    pairAddress?: SortOrderInput | SortOrder
    dexId?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    createdAt?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    pairCreatedAt?: SortOrderInput | SortOrder
    lastIngestedAt?: SortOrderInput | SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
    threatLevel?: SortOrder
    smartWalletFlow?: SortOrder
    clusterDetected?: SortOrder
    aiSummary?: SortOrderInput | SortOrder
    aiSummaryUpdated?: SortOrderInput | SortOrder
    snapshots?: MarketSnapshotOrderByRelationAggregateInput
    walletEvents?: WalletEventOrderByRelationAggregateInput
    transactions?: WalletTransactionOrderByRelationAggregateInput
    signal?: SignalOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_chain?: TokenContract_chainCompoundUniqueInput
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    name?: StringFilter<"Token"> | string
    ticker?: StringFilter<"Token"> | string
    contract?: StringFilter<"Token"> | string
    chain?: StringFilter<"Token"> | string
    pairAddress?: StringNullableFilter<"Token"> | string | null
    dexId?: StringNullableFilter<"Token"> | string | null
    logoUrl?: StringNullableFilter<"Token"> | string | null
    price?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFilter<"Token"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Token"> | Date | string
    firstSeenAt?: DateTimeFilter<"Token"> | Date | string
    lastSeenAt?: DateTimeFilter<"Token"> | Date | string
    pairCreatedAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    lastIngestedAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    momentumScore?: IntFilter<"Token"> | number
    convictionScore?: IntFilter<"Token"> | number
    threatLevel?: StringFilter<"Token"> | string
    smartWalletFlow?: BoolFilter<"Token"> | boolean
    clusterDetected?: BoolFilter<"Token"> | boolean
    aiSummary?: StringNullableFilter<"Token"> | string | null
    aiSummaryUpdated?: DateTimeNullableFilter<"Token"> | Date | string | null
    snapshots?: MarketSnapshotListRelationFilter
    walletEvents?: WalletEventListRelationFilter
    transactions?: WalletTransactionListRelationFilter
    signal?: XOR<SignalNullableScalarRelationFilter, SignalWhereInput> | null
  }, "id" | "contract_chain">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    contract?: SortOrder
    chain?: SortOrder
    pairAddress?: SortOrderInput | SortOrder
    dexId?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    createdAt?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    pairCreatedAt?: SortOrderInput | SortOrder
    lastIngestedAt?: SortOrderInput | SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
    threatLevel?: SortOrder
    smartWalletFlow?: SortOrder
    clusterDetected?: SortOrder
    aiSummary?: SortOrderInput | SortOrder
    aiSummaryUpdated?: SortOrderInput | SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    name?: StringWithAggregatesFilter<"Token"> | string
    ticker?: StringWithAggregatesFilter<"Token"> | string
    contract?: StringWithAggregatesFilter<"Token"> | string
    chain?: StringWithAggregatesFilter<"Token"> | string
    pairAddress?: StringNullableWithAggregatesFilter<"Token"> | string | null
    dexId?: StringNullableWithAggregatesFilter<"Token"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Token"> | string | null
    price?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalWithAggregatesFilter<"Token"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    firstSeenAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    pairCreatedAt?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
    lastIngestedAt?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
    momentumScore?: IntWithAggregatesFilter<"Token"> | number
    convictionScore?: IntWithAggregatesFilter<"Token"> | number
    threatLevel?: StringWithAggregatesFilter<"Token"> | string
    smartWalletFlow?: BoolWithAggregatesFilter<"Token"> | boolean
    clusterDetected?: BoolWithAggregatesFilter<"Token"> | boolean
    aiSummary?: StringNullableWithAggregatesFilter<"Token"> | string | null
    aiSummaryUpdated?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
  }

  export type MarketSnapshotWhereInput = {
    AND?: MarketSnapshotWhereInput | MarketSnapshotWhereInput[]
    OR?: MarketSnapshotWhereInput[]
    NOT?: MarketSnapshotWhereInput | MarketSnapshotWhereInput[]
    id?: StringFilter<"MarketSnapshot"> | string
    tokenId?: StringFilter<"MarketSnapshot"> | string
    price?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    volume?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    fdv?: DecimalNullableFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: DecimalNullableFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFilter<"MarketSnapshot"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }

  export type MarketSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrderInput | SortOrder
    priceChange24h?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    token?: TokenOrderByWithRelationInput
  }

  export type MarketSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketSnapshotWhereInput | MarketSnapshotWhereInput[]
    OR?: MarketSnapshotWhereInput[]
    NOT?: MarketSnapshotWhereInput | MarketSnapshotWhereInput[]
    tokenId?: StringFilter<"MarketSnapshot"> | string
    price?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    volume?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    fdv?: DecimalNullableFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: DecimalNullableFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFilter<"MarketSnapshot"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }, "id">

  export type MarketSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrderInput | SortOrder
    priceChange24h?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: MarketSnapshotCountOrderByAggregateInput
    _avg?: MarketSnapshotAvgOrderByAggregateInput
    _max?: MarketSnapshotMaxOrderByAggregateInput
    _min?: MarketSnapshotMinOrderByAggregateInput
    _sum?: MarketSnapshotSumOrderByAggregateInput
  }

  export type MarketSnapshotScalarWhereWithAggregatesInput = {
    AND?: MarketSnapshotScalarWhereWithAggregatesInput | MarketSnapshotScalarWhereWithAggregatesInput[]
    OR?: MarketSnapshotScalarWhereWithAggregatesInput[]
    NOT?: MarketSnapshotScalarWhereWithAggregatesInput | MarketSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketSnapshot"> | string
    tokenId?: StringWithAggregatesFilter<"MarketSnapshot"> | string
    price?: DecimalWithAggregatesFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalWithAggregatesFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    volume?: DecimalWithAggregatesFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalWithAggregatesFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    fdv?: DecimalNullableWithAggregatesFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: DecimalNullableWithAggregatesFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeWithAggregatesFilter<"MarketSnapshot"> | Date | string
  }

  export type WalletEventWhereInput = {
    AND?: WalletEventWhereInput | WalletEventWhereInput[]
    OR?: WalletEventWhereInput[]
    NOT?: WalletEventWhereInput | WalletEventWhereInput[]
    id?: StringFilter<"WalletEvent"> | string
    tokenId?: StringFilter<"WalletEvent"> | string
    wallet?: StringFilter<"WalletEvent"> | string
    action?: StringFilter<"WalletEvent"> | string
    amount?: DecimalFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    label?: StringNullableFilter<"WalletEvent"> | string | null
    timestamp?: DateTimeFilter<"WalletEvent"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }

  export type WalletEventOrderByWithRelationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    wallet?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    usdValue?: SortOrder
    label?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    token?: TokenOrderByWithRelationInput
  }

  export type WalletEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletEventWhereInput | WalletEventWhereInput[]
    OR?: WalletEventWhereInput[]
    NOT?: WalletEventWhereInput | WalletEventWhereInput[]
    tokenId?: StringFilter<"WalletEvent"> | string
    wallet?: StringFilter<"WalletEvent"> | string
    action?: StringFilter<"WalletEvent"> | string
    amount?: DecimalFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    label?: StringNullableFilter<"WalletEvent"> | string | null
    timestamp?: DateTimeFilter<"WalletEvent"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }, "id">

  export type WalletEventOrderByWithAggregationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    wallet?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    usdValue?: SortOrder
    label?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: WalletEventCountOrderByAggregateInput
    _avg?: WalletEventAvgOrderByAggregateInput
    _max?: WalletEventMaxOrderByAggregateInput
    _min?: WalletEventMinOrderByAggregateInput
    _sum?: WalletEventSumOrderByAggregateInput
  }

  export type WalletEventScalarWhereWithAggregatesInput = {
    AND?: WalletEventScalarWhereWithAggregatesInput | WalletEventScalarWhereWithAggregatesInput[]
    OR?: WalletEventScalarWhereWithAggregatesInput[]
    NOT?: WalletEventScalarWhereWithAggregatesInput | WalletEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletEvent"> | string
    tokenId?: StringWithAggregatesFilter<"WalletEvent"> | string
    wallet?: StringWithAggregatesFilter<"WalletEvent"> | string
    action?: StringWithAggregatesFilter<"WalletEvent"> | string
    amount?: DecimalWithAggregatesFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalWithAggregatesFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    label?: StringNullableWithAggregatesFilter<"WalletEvent"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"WalletEvent"> | Date | string
  }

  export type SignalWhereInput = {
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    tokenId?: StringFilter<"Signal"> | string
    convictionScore?: IntFilter<"Signal"> | number
    smartMoneyScore?: IntFilter<"Signal"> | number
    whaleScore?: IntFilter<"Signal"> | number
    edgeScore?: IntFilter<"Signal"> | number
    momentumPhase?: StringFilter<"Signal"> | string
    threatLevel?: StringFilter<"Signal"> | string
    edgeVerdict?: StringFilter<"Signal"> | string
    confidence?: IntFilter<"Signal"> | number
    updatedAt?: DateTimeFilter<"Signal"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }

  export type SignalOrderByWithRelationInput = {
    tokenId?: SortOrder
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    momentumPhase?: SortOrder
    threatLevel?: SortOrder
    edgeVerdict?: SortOrder
    confidence?: SortOrder
    updatedAt?: SortOrder
    token?: TokenOrderByWithRelationInput
  }

  export type SignalWhereUniqueInput = Prisma.AtLeast<{
    tokenId?: string
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    convictionScore?: IntFilter<"Signal"> | number
    smartMoneyScore?: IntFilter<"Signal"> | number
    whaleScore?: IntFilter<"Signal"> | number
    edgeScore?: IntFilter<"Signal"> | number
    momentumPhase?: StringFilter<"Signal"> | string
    threatLevel?: StringFilter<"Signal"> | string
    edgeVerdict?: StringFilter<"Signal"> | string
    confidence?: IntFilter<"Signal"> | number
    updatedAt?: DateTimeFilter<"Signal"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }, "tokenId">

  export type SignalOrderByWithAggregationInput = {
    tokenId?: SortOrder
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    momentumPhase?: SortOrder
    threatLevel?: SortOrder
    edgeVerdict?: SortOrder
    confidence?: SortOrder
    updatedAt?: SortOrder
    _count?: SignalCountOrderByAggregateInput
    _avg?: SignalAvgOrderByAggregateInput
    _max?: SignalMaxOrderByAggregateInput
    _min?: SignalMinOrderByAggregateInput
    _sum?: SignalSumOrderByAggregateInput
  }

  export type SignalScalarWhereWithAggregatesInput = {
    AND?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    OR?: SignalScalarWhereWithAggregatesInput[]
    NOT?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    tokenId?: StringWithAggregatesFilter<"Signal"> | string
    convictionScore?: IntWithAggregatesFilter<"Signal"> | number
    smartMoneyScore?: IntWithAggregatesFilter<"Signal"> | number
    whaleScore?: IntWithAggregatesFilter<"Signal"> | number
    edgeScore?: IntWithAggregatesFilter<"Signal"> | number
    momentumPhase?: StringWithAggregatesFilter<"Signal"> | string
    threatLevel?: StringWithAggregatesFilter<"Signal"> | string
    edgeVerdict?: StringWithAggregatesFilter<"Signal"> | string
    confidence?: IntWithAggregatesFilter<"Signal"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    tokenId?: StringFilter<"WalletTransaction"> | string
    walletAddress?: StringFilter<"WalletTransaction"> | string
    amountUsd?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    side?: StringFilter<"WalletTransaction"> | string
    timestamp?: DateTimeFilter<"WalletTransaction"> | Date | string
    signature?: StringFilter<"WalletTransaction"> | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    walletAddress?: SortOrder
    amountUsd?: SortOrder
    side?: SortOrder
    timestamp?: SortOrder
    signature?: SortOrder
    token?: TokenOrderByWithRelationInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    signature?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    tokenId?: StringFilter<"WalletTransaction"> | string
    walletAddress?: StringFilter<"WalletTransaction"> | string
    amountUsd?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    side?: StringFilter<"WalletTransaction"> | string
    timestamp?: DateTimeFilter<"WalletTransaction"> | Date | string
    token?: XOR<TokenScalarRelationFilter, TokenWhereInput>
  }, "id" | "signature">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    walletAddress?: SortOrder
    amountUsd?: SortOrder
    side?: SortOrder
    timestamp?: SortOrder
    signature?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    tokenId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletAddress?: StringWithAggregatesFilter<"WalletTransaction"> | string
    amountUsd?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    side?: StringWithAggregatesFilter<"WalletTransaction"> | string
    timestamp?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
    signature?: StringWithAggregatesFilter<"WalletTransaction"> | string
  }

  export type SmartWalletWhereInput = {
    AND?: SmartWalletWhereInput | SmartWalletWhereInput[]
    OR?: SmartWalletWhereInput[]
    NOT?: SmartWalletWhereInput | SmartWalletWhereInput[]
    walletAddress?: StringFilter<"SmartWallet"> | string
    smartScore?: IntFilter<"SmartWallet"> | number
    totalWins?: IntFilter<"SmartWallet"> | number
    totalTrades?: IntFilter<"SmartWallet"> | number
    avgEntryPosition?: DecimalFilter<"SmartWallet"> | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeFilter<"SmartWallet"> | Date | string
  }

  export type SmartWalletOrderByWithRelationInput = {
    walletAddress?: SortOrder
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
    lastActive?: SortOrder
  }

  export type SmartWalletWhereUniqueInput = Prisma.AtLeast<{
    walletAddress?: string
    AND?: SmartWalletWhereInput | SmartWalletWhereInput[]
    OR?: SmartWalletWhereInput[]
    NOT?: SmartWalletWhereInput | SmartWalletWhereInput[]
    smartScore?: IntFilter<"SmartWallet"> | number
    totalWins?: IntFilter<"SmartWallet"> | number
    totalTrades?: IntFilter<"SmartWallet"> | number
    avgEntryPosition?: DecimalFilter<"SmartWallet"> | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeFilter<"SmartWallet"> | Date | string
  }, "walletAddress">

  export type SmartWalletOrderByWithAggregationInput = {
    walletAddress?: SortOrder
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
    lastActive?: SortOrder
    _count?: SmartWalletCountOrderByAggregateInput
    _avg?: SmartWalletAvgOrderByAggregateInput
    _max?: SmartWalletMaxOrderByAggregateInput
    _min?: SmartWalletMinOrderByAggregateInput
    _sum?: SmartWalletSumOrderByAggregateInput
  }

  export type SmartWalletScalarWhereWithAggregatesInput = {
    AND?: SmartWalletScalarWhereWithAggregatesInput | SmartWalletScalarWhereWithAggregatesInput[]
    OR?: SmartWalletScalarWhereWithAggregatesInput[]
    NOT?: SmartWalletScalarWhereWithAggregatesInput | SmartWalletScalarWhereWithAggregatesInput[]
    walletAddress?: StringWithAggregatesFilter<"SmartWallet"> | string
    smartScore?: IntWithAggregatesFilter<"SmartWallet"> | number
    totalWins?: IntWithAggregatesFilter<"SmartWallet"> | number
    totalTrades?: IntWithAggregatesFilter<"SmartWallet"> | number
    avgEntryPosition?: DecimalWithAggregatesFilter<"SmartWallet"> | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeWithAggregatesFilter<"SmartWallet"> | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotCreateNestedManyWithoutTokenInput
    walletEvents?: WalletEventCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionCreateNestedManyWithoutTokenInput
    signal?: SignalCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotUncheckedCreateNestedManyWithoutTokenInput
    walletEvents?: WalletEventUncheckedCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutTokenInput
    signal?: SignalUncheckedCreateNestedOneWithoutTokenInput
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUpdateManyWithoutTokenNestedInput
    walletEvents?: WalletEventUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUpdateManyWithoutTokenNestedInput
    signal?: SignalUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUncheckedUpdateManyWithoutTokenNestedInput
    walletEvents?: WalletEventUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUncheckedUpdateManyWithoutTokenNestedInput
    signal?: SignalUncheckedUpdateOneWithoutTokenNestedInput
  }

  export type TokenCreateManyInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MarketSnapshotCreateInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    liquidity: Decimal | DecimalJsLike | number | string
    volume: Decimal | DecimalJsLike | number | string
    marketCap: Decimal | DecimalJsLike | number | string
    fdv?: Decimal | DecimalJsLike | number | string | null
    priceChange24h?: Decimal | DecimalJsLike | number | string | null
    timestamp?: Date | string
    token: TokenCreateNestedOneWithoutSnapshotsInput
  }

  export type MarketSnapshotUncheckedCreateInput = {
    id?: string
    tokenId: string
    price: Decimal | DecimalJsLike | number | string
    liquidity: Decimal | DecimalJsLike | number | string
    volume: Decimal | DecimalJsLike | number | string
    marketCap: Decimal | DecimalJsLike | number | string
    fdv?: Decimal | DecimalJsLike | number | string | null
    priceChange24h?: Decimal | DecimalJsLike | number | string | null
    timestamp?: Date | string
  }

  export type MarketSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type MarketSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketSnapshotCreateManyInput = {
    id?: string
    tokenId: string
    price: Decimal | DecimalJsLike | number | string
    liquidity: Decimal | DecimalJsLike | number | string
    volume: Decimal | DecimalJsLike | number | string
    marketCap: Decimal | DecimalJsLike | number | string
    fdv?: Decimal | DecimalJsLike | number | string | null
    priceChange24h?: Decimal | DecimalJsLike | number | string | null
    timestamp?: Date | string
  }

  export type MarketSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletEventCreateInput = {
    id?: string
    wallet: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    usdValue: Decimal | DecimalJsLike | number | string
    label?: string | null
    timestamp?: Date | string
    token: TokenCreateNestedOneWithoutWalletEventsInput
  }

  export type WalletEventUncheckedCreateInput = {
    id?: string
    tokenId: string
    wallet: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    usdValue: Decimal | DecimalJsLike | number | string
    label?: string | null
    timestamp?: Date | string
  }

  export type WalletEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutWalletEventsNestedInput
  }

  export type WalletEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletEventCreateManyInput = {
    id?: string
    tokenId: string
    wallet: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    usdValue: Decimal | DecimalJsLike | number | string
    label?: string | null
    timestamp?: Date | string
  }

  export type WalletEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalCreateInput = {
    convictionScore: number
    smartMoneyScore?: number
    whaleScore?: number
    edgeScore?: number
    momentumPhase: string
    threatLevel: string
    edgeVerdict: string
    confidence: number
    updatedAt?: Date | string
    token: TokenCreateNestedOneWithoutSignalInput
  }

  export type SignalUncheckedCreateInput = {
    tokenId: string
    convictionScore: number
    smartMoneyScore?: number
    whaleScore?: number
    edgeScore?: number
    momentumPhase: string
    threatLevel: string
    edgeVerdict: string
    confidence: number
    updatedAt?: Date | string
  }

  export type SignalUpdateInput = {
    convictionScore?: IntFieldUpdateOperationsInput | number
    smartMoneyScore?: IntFieldUpdateOperationsInput | number
    whaleScore?: IntFieldUpdateOperationsInput | number
    edgeScore?: IntFieldUpdateOperationsInput | number
    momentumPhase?: StringFieldUpdateOperationsInput | string
    threatLevel?: StringFieldUpdateOperationsInput | string
    edgeVerdict?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: TokenUpdateOneRequiredWithoutSignalNestedInput
  }

  export type SignalUncheckedUpdateInput = {
    tokenId?: StringFieldUpdateOperationsInput | string
    convictionScore?: IntFieldUpdateOperationsInput | number
    smartMoneyScore?: IntFieldUpdateOperationsInput | number
    whaleScore?: IntFieldUpdateOperationsInput | number
    edgeScore?: IntFieldUpdateOperationsInput | number
    momentumPhase?: StringFieldUpdateOperationsInput | string
    threatLevel?: StringFieldUpdateOperationsInput | string
    edgeVerdict?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalCreateManyInput = {
    tokenId: string
    convictionScore: number
    smartMoneyScore?: number
    whaleScore?: number
    edgeScore?: number
    momentumPhase: string
    threatLevel: string
    edgeVerdict: string
    confidence: number
    updatedAt?: Date | string
  }

  export type SignalUpdateManyMutationInput = {
    convictionScore?: IntFieldUpdateOperationsInput | number
    smartMoneyScore?: IntFieldUpdateOperationsInput | number
    whaleScore?: IntFieldUpdateOperationsInput | number
    edgeScore?: IntFieldUpdateOperationsInput | number
    momentumPhase?: StringFieldUpdateOperationsInput | string
    threatLevel?: StringFieldUpdateOperationsInput | string
    edgeVerdict?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUncheckedUpdateManyInput = {
    tokenId?: StringFieldUpdateOperationsInput | string
    convictionScore?: IntFieldUpdateOperationsInput | number
    smartMoneyScore?: IntFieldUpdateOperationsInput | number
    whaleScore?: IntFieldUpdateOperationsInput | number
    edgeScore?: IntFieldUpdateOperationsInput | number
    momentumPhase?: StringFieldUpdateOperationsInput | string
    threatLevel?: StringFieldUpdateOperationsInput | string
    edgeVerdict?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    walletAddress: string
    amountUsd: Decimal | DecimalJsLike | number | string
    side: string
    timestamp: Date | string
    signature: string
    token: TokenCreateNestedOneWithoutTransactionsInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    tokenId: string
    walletAddress: string
    amountUsd: Decimal | DecimalJsLike | number | string
    side: string
    timestamp: Date | string
    signature: string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
    token?: TokenUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    tokenId: string
    walletAddress: string
    amountUsd: Decimal | DecimalJsLike | number | string
    side: string
    timestamp: Date | string
    signature: string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
  }

  export type SmartWalletCreateInput = {
    walletAddress: string
    smartScore?: number
    totalWins?: number
    totalTrades?: number
    avgEntryPosition?: Decimal | DecimalJsLike | number | string
    lastActive: Date | string
  }

  export type SmartWalletUncheckedCreateInput = {
    walletAddress: string
    smartScore?: number
    totalWins?: number
    totalTrades?: number
    avgEntryPosition?: Decimal | DecimalJsLike | number | string
    lastActive: Date | string
  }

  export type SmartWalletUpdateInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    smartScore?: IntFieldUpdateOperationsInput | number
    totalWins?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    avgEntryPosition?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmartWalletUncheckedUpdateInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    smartScore?: IntFieldUpdateOperationsInput | number
    totalWins?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    avgEntryPosition?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmartWalletCreateManyInput = {
    walletAddress: string
    smartScore?: number
    totalWins?: number
    totalTrades?: number
    avgEntryPosition?: Decimal | DecimalJsLike | number | string
    lastActive: Date | string
  }

  export type SmartWalletUpdateManyMutationInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    smartScore?: IntFieldUpdateOperationsInput | number
    totalWins?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    avgEntryPosition?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmartWalletUncheckedUpdateManyInput = {
    walletAddress?: StringFieldUpdateOperationsInput | string
    smartScore?: IntFieldUpdateOperationsInput | number
    totalWins?: IntFieldUpdateOperationsInput | number
    totalTrades?: IntFieldUpdateOperationsInput | number
    avgEntryPosition?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MarketSnapshotListRelationFilter = {
    every?: MarketSnapshotWhereInput
    some?: MarketSnapshotWhereInput
    none?: MarketSnapshotWhereInput
  }

  export type WalletEventListRelationFilter = {
    every?: WalletEventWhereInput
    some?: WalletEventWhereInput
    none?: WalletEventWhereInput
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type SignalNullableScalarRelationFilter = {
    is?: SignalWhereInput | null
    isNot?: SignalWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MarketSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenContract_chainCompoundUniqueInput = {
    contract: string
    chain: string
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    contract?: SortOrder
    chain?: SortOrder
    pairAddress?: SortOrder
    dexId?: SortOrder
    logoUrl?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    createdAt?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    pairCreatedAt?: SortOrder
    lastIngestedAt?: SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
    threatLevel?: SortOrder
    smartWalletFlow?: SortOrder
    clusterDetected?: SortOrder
    aiSummary?: SortOrder
    aiSummaryUpdated?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    contract?: SortOrder
    chain?: SortOrder
    pairAddress?: SortOrder
    dexId?: SortOrder
    logoUrl?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    createdAt?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    pairCreatedAt?: SortOrder
    lastIngestedAt?: SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
    threatLevel?: SortOrder
    smartWalletFlow?: SortOrder
    clusterDetected?: SortOrder
    aiSummary?: SortOrder
    aiSummaryUpdated?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    contract?: SortOrder
    chain?: SortOrder
    pairAddress?: SortOrder
    dexId?: SortOrder
    logoUrl?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    createdAt?: SortOrder
    firstSeenAt?: SortOrder
    lastSeenAt?: SortOrder
    pairCreatedAt?: SortOrder
    lastIngestedAt?: SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
    threatLevel?: SortOrder
    smartWalletFlow?: SortOrder
    clusterDetected?: SortOrder
    aiSummary?: SortOrder
    aiSummaryUpdated?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    price?: SortOrder
    liquidity?: SortOrder
    volume24h?: SortOrder
    marketCap?: SortOrder
    momentumScore?: SortOrder
    convictionScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type TokenScalarRelationFilter = {
    is?: TokenWhereInput
    isNot?: TokenWhereInput
  }

  export type MarketSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrder
    priceChange24h?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketSnapshotAvgOrderByAggregateInput = {
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrder
    priceChange24h?: SortOrder
  }

  export type MarketSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrder
    priceChange24h?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrder
    priceChange24h?: SortOrder
    timestamp?: SortOrder
  }

  export type MarketSnapshotSumOrderByAggregateInput = {
    price?: SortOrder
    liquidity?: SortOrder
    volume?: SortOrder
    marketCap?: SortOrder
    fdv?: SortOrder
    priceChange24h?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type WalletEventCountOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    wallet?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    usdValue?: SortOrder
    label?: SortOrder
    timestamp?: SortOrder
  }

  export type WalletEventAvgOrderByAggregateInput = {
    amount?: SortOrder
    usdValue?: SortOrder
  }

  export type WalletEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    wallet?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    usdValue?: SortOrder
    label?: SortOrder
    timestamp?: SortOrder
  }

  export type WalletEventMinOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    wallet?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    usdValue?: SortOrder
    label?: SortOrder
    timestamp?: SortOrder
  }

  export type WalletEventSumOrderByAggregateInput = {
    amount?: SortOrder
    usdValue?: SortOrder
  }

  export type SignalCountOrderByAggregateInput = {
    tokenId?: SortOrder
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    momentumPhase?: SortOrder
    threatLevel?: SortOrder
    edgeVerdict?: SortOrder
    confidence?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignalAvgOrderByAggregateInput = {
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    confidence?: SortOrder
  }

  export type SignalMaxOrderByAggregateInput = {
    tokenId?: SortOrder
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    momentumPhase?: SortOrder
    threatLevel?: SortOrder
    edgeVerdict?: SortOrder
    confidence?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignalMinOrderByAggregateInput = {
    tokenId?: SortOrder
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    momentumPhase?: SortOrder
    threatLevel?: SortOrder
    edgeVerdict?: SortOrder
    confidence?: SortOrder
    updatedAt?: SortOrder
  }

  export type SignalSumOrderByAggregateInput = {
    convictionScore?: SortOrder
    smartMoneyScore?: SortOrder
    whaleScore?: SortOrder
    edgeScore?: SortOrder
    confidence?: SortOrder
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    walletAddress?: SortOrder
    amountUsd?: SortOrder
    side?: SortOrder
    timestamp?: SortOrder
    signature?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amountUsd?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    walletAddress?: SortOrder
    amountUsd?: SortOrder
    side?: SortOrder
    timestamp?: SortOrder
    signature?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    walletAddress?: SortOrder
    amountUsd?: SortOrder
    side?: SortOrder
    timestamp?: SortOrder
    signature?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amountUsd?: SortOrder
  }

  export type SmartWalletCountOrderByAggregateInput = {
    walletAddress?: SortOrder
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
    lastActive?: SortOrder
  }

  export type SmartWalletAvgOrderByAggregateInput = {
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
  }

  export type SmartWalletMaxOrderByAggregateInput = {
    walletAddress?: SortOrder
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
    lastActive?: SortOrder
  }

  export type SmartWalletMinOrderByAggregateInput = {
    walletAddress?: SortOrder
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
    lastActive?: SortOrder
  }

  export type SmartWalletSumOrderByAggregateInput = {
    smartScore?: SortOrder
    totalWins?: SortOrder
    totalTrades?: SortOrder
    avgEntryPosition?: SortOrder
  }

  export type MarketSnapshotCreateNestedManyWithoutTokenInput = {
    create?: XOR<MarketSnapshotCreateWithoutTokenInput, MarketSnapshotUncheckedCreateWithoutTokenInput> | MarketSnapshotCreateWithoutTokenInput[] | MarketSnapshotUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MarketSnapshotCreateOrConnectWithoutTokenInput | MarketSnapshotCreateOrConnectWithoutTokenInput[]
    createMany?: MarketSnapshotCreateManyTokenInputEnvelope
    connect?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
  }

  export type WalletEventCreateNestedManyWithoutTokenInput = {
    create?: XOR<WalletEventCreateWithoutTokenInput, WalletEventUncheckedCreateWithoutTokenInput> | WalletEventCreateWithoutTokenInput[] | WalletEventUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletEventCreateOrConnectWithoutTokenInput | WalletEventCreateOrConnectWithoutTokenInput[]
    createMany?: WalletEventCreateManyTokenInputEnvelope
    connect?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
  }

  export type WalletTransactionCreateNestedManyWithoutTokenInput = {
    create?: XOR<WalletTransactionCreateWithoutTokenInput, WalletTransactionUncheckedCreateWithoutTokenInput> | WalletTransactionCreateWithoutTokenInput[] | WalletTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutTokenInput | WalletTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: WalletTransactionCreateManyTokenInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type SignalCreateNestedOneWithoutTokenInput = {
    create?: XOR<SignalCreateWithoutTokenInput, SignalUncheckedCreateWithoutTokenInput>
    connectOrCreate?: SignalCreateOrConnectWithoutTokenInput
    connect?: SignalWhereUniqueInput
  }

  export type MarketSnapshotUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<MarketSnapshotCreateWithoutTokenInput, MarketSnapshotUncheckedCreateWithoutTokenInput> | MarketSnapshotCreateWithoutTokenInput[] | MarketSnapshotUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MarketSnapshotCreateOrConnectWithoutTokenInput | MarketSnapshotCreateOrConnectWithoutTokenInput[]
    createMany?: MarketSnapshotCreateManyTokenInputEnvelope
    connect?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
  }

  export type WalletEventUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<WalletEventCreateWithoutTokenInput, WalletEventUncheckedCreateWithoutTokenInput> | WalletEventCreateWithoutTokenInput[] | WalletEventUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletEventCreateOrConnectWithoutTokenInput | WalletEventCreateOrConnectWithoutTokenInput[]
    createMany?: WalletEventCreateManyTokenInputEnvelope
    connect?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutTokenInput = {
    create?: XOR<WalletTransactionCreateWithoutTokenInput, WalletTransactionUncheckedCreateWithoutTokenInput> | WalletTransactionCreateWithoutTokenInput[] | WalletTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutTokenInput | WalletTransactionCreateOrConnectWithoutTokenInput[]
    createMany?: WalletTransactionCreateManyTokenInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type SignalUncheckedCreateNestedOneWithoutTokenInput = {
    create?: XOR<SignalCreateWithoutTokenInput, SignalUncheckedCreateWithoutTokenInput>
    connectOrCreate?: SignalCreateOrConnectWithoutTokenInput
    connect?: SignalWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MarketSnapshotUpdateManyWithoutTokenNestedInput = {
    create?: XOR<MarketSnapshotCreateWithoutTokenInput, MarketSnapshotUncheckedCreateWithoutTokenInput> | MarketSnapshotCreateWithoutTokenInput[] | MarketSnapshotUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MarketSnapshotCreateOrConnectWithoutTokenInput | MarketSnapshotCreateOrConnectWithoutTokenInput[]
    upsert?: MarketSnapshotUpsertWithWhereUniqueWithoutTokenInput | MarketSnapshotUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: MarketSnapshotCreateManyTokenInputEnvelope
    set?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    disconnect?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    delete?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    connect?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    update?: MarketSnapshotUpdateWithWhereUniqueWithoutTokenInput | MarketSnapshotUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: MarketSnapshotUpdateManyWithWhereWithoutTokenInput | MarketSnapshotUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: MarketSnapshotScalarWhereInput | MarketSnapshotScalarWhereInput[]
  }

  export type WalletEventUpdateManyWithoutTokenNestedInput = {
    create?: XOR<WalletEventCreateWithoutTokenInput, WalletEventUncheckedCreateWithoutTokenInput> | WalletEventCreateWithoutTokenInput[] | WalletEventUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletEventCreateOrConnectWithoutTokenInput | WalletEventCreateOrConnectWithoutTokenInput[]
    upsert?: WalletEventUpsertWithWhereUniqueWithoutTokenInput | WalletEventUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: WalletEventCreateManyTokenInputEnvelope
    set?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    disconnect?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    delete?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    connect?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    update?: WalletEventUpdateWithWhereUniqueWithoutTokenInput | WalletEventUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: WalletEventUpdateManyWithWhereWithoutTokenInput | WalletEventUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: WalletEventScalarWhereInput | WalletEventScalarWhereInput[]
  }

  export type WalletTransactionUpdateManyWithoutTokenNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutTokenInput, WalletTransactionUncheckedCreateWithoutTokenInput> | WalletTransactionCreateWithoutTokenInput[] | WalletTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutTokenInput | WalletTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutTokenInput | WalletTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: WalletTransactionCreateManyTokenInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutTokenInput | WalletTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutTokenInput | WalletTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type SignalUpdateOneWithoutTokenNestedInput = {
    create?: XOR<SignalCreateWithoutTokenInput, SignalUncheckedCreateWithoutTokenInput>
    connectOrCreate?: SignalCreateOrConnectWithoutTokenInput
    upsert?: SignalUpsertWithoutTokenInput
    disconnect?: SignalWhereInput | boolean
    delete?: SignalWhereInput | boolean
    connect?: SignalWhereUniqueInput
    update?: XOR<XOR<SignalUpdateToOneWithWhereWithoutTokenInput, SignalUpdateWithoutTokenInput>, SignalUncheckedUpdateWithoutTokenInput>
  }

  export type MarketSnapshotUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<MarketSnapshotCreateWithoutTokenInput, MarketSnapshotUncheckedCreateWithoutTokenInput> | MarketSnapshotCreateWithoutTokenInput[] | MarketSnapshotUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: MarketSnapshotCreateOrConnectWithoutTokenInput | MarketSnapshotCreateOrConnectWithoutTokenInput[]
    upsert?: MarketSnapshotUpsertWithWhereUniqueWithoutTokenInput | MarketSnapshotUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: MarketSnapshotCreateManyTokenInputEnvelope
    set?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    disconnect?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    delete?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    connect?: MarketSnapshotWhereUniqueInput | MarketSnapshotWhereUniqueInput[]
    update?: MarketSnapshotUpdateWithWhereUniqueWithoutTokenInput | MarketSnapshotUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: MarketSnapshotUpdateManyWithWhereWithoutTokenInput | MarketSnapshotUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: MarketSnapshotScalarWhereInput | MarketSnapshotScalarWhereInput[]
  }

  export type WalletEventUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<WalletEventCreateWithoutTokenInput, WalletEventUncheckedCreateWithoutTokenInput> | WalletEventCreateWithoutTokenInput[] | WalletEventUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletEventCreateOrConnectWithoutTokenInput | WalletEventCreateOrConnectWithoutTokenInput[]
    upsert?: WalletEventUpsertWithWhereUniqueWithoutTokenInput | WalletEventUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: WalletEventCreateManyTokenInputEnvelope
    set?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    disconnect?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    delete?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    connect?: WalletEventWhereUniqueInput | WalletEventWhereUniqueInput[]
    update?: WalletEventUpdateWithWhereUniqueWithoutTokenInput | WalletEventUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: WalletEventUpdateManyWithWhereWithoutTokenInput | WalletEventUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: WalletEventScalarWhereInput | WalletEventScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutTokenNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutTokenInput, WalletTransactionUncheckedCreateWithoutTokenInput> | WalletTransactionCreateWithoutTokenInput[] | WalletTransactionUncheckedCreateWithoutTokenInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutTokenInput | WalletTransactionCreateOrConnectWithoutTokenInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutTokenInput | WalletTransactionUpsertWithWhereUniqueWithoutTokenInput[]
    createMany?: WalletTransactionCreateManyTokenInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutTokenInput | WalletTransactionUpdateWithWhereUniqueWithoutTokenInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutTokenInput | WalletTransactionUpdateManyWithWhereWithoutTokenInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type SignalUncheckedUpdateOneWithoutTokenNestedInput = {
    create?: XOR<SignalCreateWithoutTokenInput, SignalUncheckedCreateWithoutTokenInput>
    connectOrCreate?: SignalCreateOrConnectWithoutTokenInput
    upsert?: SignalUpsertWithoutTokenInput
    disconnect?: SignalWhereInput | boolean
    delete?: SignalWhereInput | boolean
    connect?: SignalWhereUniqueInput
    update?: XOR<XOR<SignalUpdateToOneWithWhereWithoutTokenInput, SignalUpdateWithoutTokenInput>, SignalUncheckedUpdateWithoutTokenInput>
  }

  export type TokenCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<TokenCreateWithoutSnapshotsInput, TokenUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutSnapshotsInput
    connect?: TokenWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TokenUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<TokenCreateWithoutSnapshotsInput, TokenUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutSnapshotsInput
    upsert?: TokenUpsertWithoutSnapshotsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutSnapshotsInput, TokenUpdateWithoutSnapshotsInput>, TokenUncheckedUpdateWithoutSnapshotsInput>
  }

  export type TokenCreateNestedOneWithoutWalletEventsInput = {
    create?: XOR<TokenCreateWithoutWalletEventsInput, TokenUncheckedCreateWithoutWalletEventsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutWalletEventsInput
    connect?: TokenWhereUniqueInput
  }

  export type TokenUpdateOneRequiredWithoutWalletEventsNestedInput = {
    create?: XOR<TokenCreateWithoutWalletEventsInput, TokenUncheckedCreateWithoutWalletEventsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutWalletEventsInput
    upsert?: TokenUpsertWithoutWalletEventsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutWalletEventsInput, TokenUpdateWithoutWalletEventsInput>, TokenUncheckedUpdateWithoutWalletEventsInput>
  }

  export type TokenCreateNestedOneWithoutSignalInput = {
    create?: XOR<TokenCreateWithoutSignalInput, TokenUncheckedCreateWithoutSignalInput>
    connectOrCreate?: TokenCreateOrConnectWithoutSignalInput
    connect?: TokenWhereUniqueInput
  }

  export type TokenUpdateOneRequiredWithoutSignalNestedInput = {
    create?: XOR<TokenCreateWithoutSignalInput, TokenUncheckedCreateWithoutSignalInput>
    connectOrCreate?: TokenCreateOrConnectWithoutSignalInput
    upsert?: TokenUpsertWithoutSignalInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutSignalInput, TokenUpdateWithoutSignalInput>, TokenUncheckedUpdateWithoutSignalInput>
  }

  export type TokenCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TokenCreateWithoutTransactionsInput, TokenUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutTransactionsInput
    connect?: TokenWhereUniqueInput
  }

  export type TokenUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<TokenCreateWithoutTransactionsInput, TokenUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TokenCreateOrConnectWithoutTransactionsInput
    upsert?: TokenUpsertWithoutTransactionsInput
    connect?: TokenWhereUniqueInput
    update?: XOR<XOR<TokenUpdateToOneWithWhereWithoutTransactionsInput, TokenUpdateWithoutTransactionsInput>, TokenUncheckedUpdateWithoutTransactionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type MarketSnapshotCreateWithoutTokenInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    liquidity: Decimal | DecimalJsLike | number | string
    volume: Decimal | DecimalJsLike | number | string
    marketCap: Decimal | DecimalJsLike | number | string
    fdv?: Decimal | DecimalJsLike | number | string | null
    priceChange24h?: Decimal | DecimalJsLike | number | string | null
    timestamp?: Date | string
  }

  export type MarketSnapshotUncheckedCreateWithoutTokenInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    liquidity: Decimal | DecimalJsLike | number | string
    volume: Decimal | DecimalJsLike | number | string
    marketCap: Decimal | DecimalJsLike | number | string
    fdv?: Decimal | DecimalJsLike | number | string | null
    priceChange24h?: Decimal | DecimalJsLike | number | string | null
    timestamp?: Date | string
  }

  export type MarketSnapshotCreateOrConnectWithoutTokenInput = {
    where: MarketSnapshotWhereUniqueInput
    create: XOR<MarketSnapshotCreateWithoutTokenInput, MarketSnapshotUncheckedCreateWithoutTokenInput>
  }

  export type MarketSnapshotCreateManyTokenInputEnvelope = {
    data: MarketSnapshotCreateManyTokenInput | MarketSnapshotCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type WalletEventCreateWithoutTokenInput = {
    id?: string
    wallet: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    usdValue: Decimal | DecimalJsLike | number | string
    label?: string | null
    timestamp?: Date | string
  }

  export type WalletEventUncheckedCreateWithoutTokenInput = {
    id?: string
    wallet: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    usdValue: Decimal | DecimalJsLike | number | string
    label?: string | null
    timestamp?: Date | string
  }

  export type WalletEventCreateOrConnectWithoutTokenInput = {
    where: WalletEventWhereUniqueInput
    create: XOR<WalletEventCreateWithoutTokenInput, WalletEventUncheckedCreateWithoutTokenInput>
  }

  export type WalletEventCreateManyTokenInputEnvelope = {
    data: WalletEventCreateManyTokenInput | WalletEventCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type WalletTransactionCreateWithoutTokenInput = {
    id?: string
    walletAddress: string
    amountUsd: Decimal | DecimalJsLike | number | string
    side: string
    timestamp: Date | string
    signature: string
  }

  export type WalletTransactionUncheckedCreateWithoutTokenInput = {
    id?: string
    walletAddress: string
    amountUsd: Decimal | DecimalJsLike | number | string
    side: string
    timestamp: Date | string
    signature: string
  }

  export type WalletTransactionCreateOrConnectWithoutTokenInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutTokenInput, WalletTransactionUncheckedCreateWithoutTokenInput>
  }

  export type WalletTransactionCreateManyTokenInputEnvelope = {
    data: WalletTransactionCreateManyTokenInput | WalletTransactionCreateManyTokenInput[]
    skipDuplicates?: boolean
  }

  export type SignalCreateWithoutTokenInput = {
    convictionScore: number
    smartMoneyScore?: number
    whaleScore?: number
    edgeScore?: number
    momentumPhase: string
    threatLevel: string
    edgeVerdict: string
    confidence: number
    updatedAt?: Date | string
  }

  export type SignalUncheckedCreateWithoutTokenInput = {
    convictionScore: number
    smartMoneyScore?: number
    whaleScore?: number
    edgeScore?: number
    momentumPhase: string
    threatLevel: string
    edgeVerdict: string
    confidence: number
    updatedAt?: Date | string
  }

  export type SignalCreateOrConnectWithoutTokenInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutTokenInput, SignalUncheckedCreateWithoutTokenInput>
  }

  export type MarketSnapshotUpsertWithWhereUniqueWithoutTokenInput = {
    where: MarketSnapshotWhereUniqueInput
    update: XOR<MarketSnapshotUpdateWithoutTokenInput, MarketSnapshotUncheckedUpdateWithoutTokenInput>
    create: XOR<MarketSnapshotCreateWithoutTokenInput, MarketSnapshotUncheckedCreateWithoutTokenInput>
  }

  export type MarketSnapshotUpdateWithWhereUniqueWithoutTokenInput = {
    where: MarketSnapshotWhereUniqueInput
    data: XOR<MarketSnapshotUpdateWithoutTokenInput, MarketSnapshotUncheckedUpdateWithoutTokenInput>
  }

  export type MarketSnapshotUpdateManyWithWhereWithoutTokenInput = {
    where: MarketSnapshotScalarWhereInput
    data: XOR<MarketSnapshotUpdateManyMutationInput, MarketSnapshotUncheckedUpdateManyWithoutTokenInput>
  }

  export type MarketSnapshotScalarWhereInput = {
    AND?: MarketSnapshotScalarWhereInput | MarketSnapshotScalarWhereInput[]
    OR?: MarketSnapshotScalarWhereInput[]
    NOT?: MarketSnapshotScalarWhereInput | MarketSnapshotScalarWhereInput[]
    id?: StringFilter<"MarketSnapshot"> | string
    tokenId?: StringFilter<"MarketSnapshot"> | string
    price?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    volume?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string
    fdv?: DecimalNullableFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: DecimalNullableFilter<"MarketSnapshot"> | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFilter<"MarketSnapshot"> | Date | string
  }

  export type WalletEventUpsertWithWhereUniqueWithoutTokenInput = {
    where: WalletEventWhereUniqueInput
    update: XOR<WalletEventUpdateWithoutTokenInput, WalletEventUncheckedUpdateWithoutTokenInput>
    create: XOR<WalletEventCreateWithoutTokenInput, WalletEventUncheckedCreateWithoutTokenInput>
  }

  export type WalletEventUpdateWithWhereUniqueWithoutTokenInput = {
    where: WalletEventWhereUniqueInput
    data: XOR<WalletEventUpdateWithoutTokenInput, WalletEventUncheckedUpdateWithoutTokenInput>
  }

  export type WalletEventUpdateManyWithWhereWithoutTokenInput = {
    where: WalletEventScalarWhereInput
    data: XOR<WalletEventUpdateManyMutationInput, WalletEventUncheckedUpdateManyWithoutTokenInput>
  }

  export type WalletEventScalarWhereInput = {
    AND?: WalletEventScalarWhereInput | WalletEventScalarWhereInput[]
    OR?: WalletEventScalarWhereInput[]
    NOT?: WalletEventScalarWhereInput | WalletEventScalarWhereInput[]
    id?: StringFilter<"WalletEvent"> | string
    tokenId?: StringFilter<"WalletEvent"> | string
    wallet?: StringFilter<"WalletEvent"> | string
    action?: StringFilter<"WalletEvent"> | string
    amount?: DecimalFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFilter<"WalletEvent"> | Decimal | DecimalJsLike | number | string
    label?: StringNullableFilter<"WalletEvent"> | string | null
    timestamp?: DateTimeFilter<"WalletEvent"> | Date | string
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutTokenInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutTokenInput, WalletTransactionUncheckedUpdateWithoutTokenInput>
    create: XOR<WalletTransactionCreateWithoutTokenInput, WalletTransactionUncheckedCreateWithoutTokenInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutTokenInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutTokenInput, WalletTransactionUncheckedUpdateWithoutTokenInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutTokenInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutTokenInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    tokenId?: StringFilter<"WalletTransaction"> | string
    walletAddress?: StringFilter<"WalletTransaction"> | string
    amountUsd?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    side?: StringFilter<"WalletTransaction"> | string
    timestamp?: DateTimeFilter<"WalletTransaction"> | Date | string
    signature?: StringFilter<"WalletTransaction"> | string
  }

  export type SignalUpsertWithoutTokenInput = {
    update: XOR<SignalUpdateWithoutTokenInput, SignalUncheckedUpdateWithoutTokenInput>
    create: XOR<SignalCreateWithoutTokenInput, SignalUncheckedCreateWithoutTokenInput>
    where?: SignalWhereInput
  }

  export type SignalUpdateToOneWithWhereWithoutTokenInput = {
    where?: SignalWhereInput
    data: XOR<SignalUpdateWithoutTokenInput, SignalUncheckedUpdateWithoutTokenInput>
  }

  export type SignalUpdateWithoutTokenInput = {
    convictionScore?: IntFieldUpdateOperationsInput | number
    smartMoneyScore?: IntFieldUpdateOperationsInput | number
    whaleScore?: IntFieldUpdateOperationsInput | number
    edgeScore?: IntFieldUpdateOperationsInput | number
    momentumPhase?: StringFieldUpdateOperationsInput | string
    threatLevel?: StringFieldUpdateOperationsInput | string
    edgeVerdict?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUncheckedUpdateWithoutTokenInput = {
    convictionScore?: IntFieldUpdateOperationsInput | number
    smartMoneyScore?: IntFieldUpdateOperationsInput | number
    whaleScore?: IntFieldUpdateOperationsInput | number
    edgeScore?: IntFieldUpdateOperationsInput | number
    momentumPhase?: StringFieldUpdateOperationsInput | string
    threatLevel?: StringFieldUpdateOperationsInput | string
    edgeVerdict?: StringFieldUpdateOperationsInput | string
    confidence?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    walletEvents?: WalletEventCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionCreateNestedManyWithoutTokenInput
    signal?: SignalCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    walletEvents?: WalletEventUncheckedCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutTokenInput
    signal?: SignalUncheckedCreateNestedOneWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutSnapshotsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutSnapshotsInput, TokenUncheckedCreateWithoutSnapshotsInput>
  }

  export type TokenUpsertWithoutSnapshotsInput = {
    update: XOR<TokenUpdateWithoutSnapshotsInput, TokenUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<TokenCreateWithoutSnapshotsInput, TokenUncheckedCreateWithoutSnapshotsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutSnapshotsInput, TokenUncheckedUpdateWithoutSnapshotsInput>
  }

  export type TokenUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletEvents?: WalletEventUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUpdateManyWithoutTokenNestedInput
    signal?: SignalUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    walletEvents?: WalletEventUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUncheckedUpdateManyWithoutTokenNestedInput
    signal?: SignalUncheckedUpdateOneWithoutTokenNestedInput
  }

  export type TokenCreateWithoutWalletEventsInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionCreateNestedManyWithoutTokenInput
    signal?: SignalCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutWalletEventsInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotUncheckedCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutTokenInput
    signal?: SignalUncheckedCreateNestedOneWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutWalletEventsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutWalletEventsInput, TokenUncheckedCreateWithoutWalletEventsInput>
  }

  export type TokenUpsertWithoutWalletEventsInput = {
    update: XOR<TokenUpdateWithoutWalletEventsInput, TokenUncheckedUpdateWithoutWalletEventsInput>
    create: XOR<TokenCreateWithoutWalletEventsInput, TokenUncheckedCreateWithoutWalletEventsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutWalletEventsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutWalletEventsInput, TokenUncheckedUpdateWithoutWalletEventsInput>
  }

  export type TokenUpdateWithoutWalletEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUpdateManyWithoutTokenNestedInput
    signal?: SignalUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutWalletEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUncheckedUpdateManyWithoutTokenNestedInput
    signal?: SignalUncheckedUpdateOneWithoutTokenNestedInput
  }

  export type TokenCreateWithoutSignalInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotCreateNestedManyWithoutTokenInput
    walletEvents?: WalletEventCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionCreateNestedManyWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutSignalInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotUncheckedCreateNestedManyWithoutTokenInput
    walletEvents?: WalletEventUncheckedCreateNestedManyWithoutTokenInput
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutSignalInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutSignalInput, TokenUncheckedCreateWithoutSignalInput>
  }

  export type TokenUpsertWithoutSignalInput = {
    update: XOR<TokenUpdateWithoutSignalInput, TokenUncheckedUpdateWithoutSignalInput>
    create: XOR<TokenCreateWithoutSignalInput, TokenUncheckedCreateWithoutSignalInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutSignalInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutSignalInput, TokenUncheckedUpdateWithoutSignalInput>
  }

  export type TokenUpdateWithoutSignalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUpdateManyWithoutTokenNestedInput
    walletEvents?: WalletEventUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUpdateManyWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutSignalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUncheckedUpdateManyWithoutTokenNestedInput
    walletEvents?: WalletEventUncheckedUpdateManyWithoutTokenNestedInput
    transactions?: WalletTransactionUncheckedUpdateManyWithoutTokenNestedInput
  }

  export type TokenCreateWithoutTransactionsInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotCreateNestedManyWithoutTokenInput
    walletEvents?: WalletEventCreateNestedManyWithoutTokenInput
    signal?: SignalCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    ticker: string
    contract: string
    chain?: string
    pairAddress?: string | null
    dexId?: string | null
    logoUrl?: string | null
    price?: Decimal | DecimalJsLike | number | string
    liquidity?: Decimal | DecimalJsLike | number | string
    volume24h?: Decimal | DecimalJsLike | number | string
    marketCap?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    firstSeenAt?: Date | string
    lastSeenAt?: Date | string
    pairCreatedAt?: Date | string | null
    lastIngestedAt?: Date | string | null
    momentumScore?: number
    convictionScore?: number
    threatLevel?: string
    smartWalletFlow?: boolean
    clusterDetected?: boolean
    aiSummary?: string | null
    aiSummaryUpdated?: Date | string | null
    snapshots?: MarketSnapshotUncheckedCreateNestedManyWithoutTokenInput
    walletEvents?: WalletEventUncheckedCreateNestedManyWithoutTokenInput
    signal?: SignalUncheckedCreateNestedOneWithoutTokenInput
  }

  export type TokenCreateOrConnectWithoutTransactionsInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutTransactionsInput, TokenUncheckedCreateWithoutTransactionsInput>
  }

  export type TokenUpsertWithoutTransactionsInput = {
    update: XOR<TokenUpdateWithoutTransactionsInput, TokenUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TokenCreateWithoutTransactionsInput, TokenUncheckedCreateWithoutTransactionsInput>
    where?: TokenWhereInput
  }

  export type TokenUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TokenWhereInput
    data: XOR<TokenUpdateWithoutTransactionsInput, TokenUncheckedUpdateWithoutTransactionsInput>
  }

  export type TokenUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUpdateManyWithoutTokenNestedInput
    walletEvents?: WalletEventUpdateManyWithoutTokenNestedInput
    signal?: SignalUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    pairAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dexId?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume24h?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pairCreatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastIngestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    momentumScore?: IntFieldUpdateOperationsInput | number
    convictionScore?: IntFieldUpdateOperationsInput | number
    threatLevel?: StringFieldUpdateOperationsInput | string
    smartWalletFlow?: BoolFieldUpdateOperationsInput | boolean
    clusterDetected?: BoolFieldUpdateOperationsInput | boolean
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    aiSummaryUpdated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snapshots?: MarketSnapshotUncheckedUpdateManyWithoutTokenNestedInput
    walletEvents?: WalletEventUncheckedUpdateManyWithoutTokenNestedInput
    signal?: SignalUncheckedUpdateOneWithoutTokenNestedInput
  }

  export type MarketSnapshotCreateManyTokenInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    liquidity: Decimal | DecimalJsLike | number | string
    volume: Decimal | DecimalJsLike | number | string
    marketCap: Decimal | DecimalJsLike | number | string
    fdv?: Decimal | DecimalJsLike | number | string | null
    priceChange24h?: Decimal | DecimalJsLike | number | string | null
    timestamp?: Date | string
  }

  export type WalletEventCreateManyTokenInput = {
    id?: string
    wallet: string
    action: string
    amount: Decimal | DecimalJsLike | number | string
    usdValue: Decimal | DecimalJsLike | number | string
    label?: string | null
    timestamp?: Date | string
  }

  export type WalletTransactionCreateManyTokenInput = {
    id?: string
    walletAddress: string
    amountUsd: Decimal | DecimalJsLike | number | string
    side: string
    timestamp: Date | string
    signature: string
  }

  export type MarketSnapshotUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketSnapshotUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketSnapshotUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    liquidity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    volume?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fdv?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceChange24h?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletEventUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletEventUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletEventUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    wallet?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usdValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
  }

  export type WalletTransactionUncheckedUpdateWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    side?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}